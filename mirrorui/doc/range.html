<div class=doc-page><h2>范围滑块</h2><p>滑块,使用自定义标记 &lt;m-range>&lt;/m-range><p>绑定了鼠标事件和触摸事件,按住滑块按钮拖动改变滑块的值.事件绑定在容器元素上,没用绑定在滑块按钮上,为了实现当鼠标不在按钮上时,也能触发滑动事件.<p>滑条的变化是通过修改左边框的厚度实现,滑块在滑条中一直贴着左边框,被动的向右边移动.<div><m-range></m-range><m-range class=sky min=0 max=100 val=30></m-range></div><h4>属性</h4><p><b class=txt-sky-4>width</b> 滑动条的长度,默认320px<p><b class=txt-sky-4>min</b> 范围边界小值,默认0<p><b class=txt-sky-4>max</b> 范围边界大值,默认100<p><b class=txt-sky-4>val</b> 初始值,默认0<pre>
&lt;m-range>&lt;/m-range>
&lt;m-range id="range1" width="320" min="0" max="100" val="0">&lt;/m-range>
</pre><p><b class=txt-sky-4>Value</b> 获取/设置滑块值<pre>
// Value值,在[min,max]之间的值
range1.Value=50;
let val=range1.Value;
</pre><h4>事件</h4><p><b class=txt-sky-4>onChange=handler(val)</b> 滑动时执行.val滑块的值.<pre>
// val: 当前滑块的值
range1.<b>onChange</b> = (val)=>{
  console.log(val)
}
</pre><h4>测试</h4><p>绑定滑动事件,这个例子中,获取滑块的值,在canvas里绘制小方块的个数</p><br><m-range id=range1 class=blue width=600 min=0 max=100 val=0></m-range><canvas id=canvasrange1 class="bd-1 bd-gray-3"></canvas></div><script>(()=>{function l(n,r){for(var u=0,f=t.length;u<f;u++)if(n==t[u]&&r==i[u])return!0;return!1}function a(n){let t=parseInt(n/o),i=n%s;return[t,i]}function v(n,t,i,u,f,e){n.beginPath();n.fillStyle="#"+r(0,256).toString(16)+r(0,256).toString(16)+r(0,256).toString(16);n.fillRect(t,i,u,f);n.fillStyle="white";n.fillText(e,t+(e<10?u/3:u/5),i+2*f/3)}function r(n,t){let i=Math.random()*(t-n);return Math.floor(i)+n}let n=document.getElementById("canvasrange1"),u=n.getContext("2d");n.width=512;n.height=256;let f=16,e=16,o=16,s=16,h=n.width/f*(n.height/e),t=[],i=[],c=document.getElementById("range1");c.onChange=c=>{let p=c;t.length=i.length=0;for(let n=0;n<p;n++){let f=r(0,h),u=a(f);if(l(u[0],u[1])){n--;continue}t.push(u[0]);i.push(u[1])}u.clearRect(0,0,n.width,n.height);for(var y=0,w=t.length;y<w;y++){let n=t[y],r=i[y];v(u,n*f,r*e,s,o,y)}}})()</script>