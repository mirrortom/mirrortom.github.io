<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>canvas动画| canvas-demo | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class="layout-part2 layout-doc"><div id=page_content><h2>动画场景</h2><p><small>最后更新时间:2022/3/24</small><h3>抬手动作</h3><p>人眼看到画布上会动的影像,本质上和看一张照片一样.假如对一个站立的人拍照,那么得到一张站立着的照片,这个人抬起左手后,再拍照,得到<p>其抬起左手的照片,再放下左手拍照,又得到一张站立着的照片.此时会得到三张照片,在电脑上轮播这三张照片,如果播放速度比较快,那给观看<p>照片的人感觉就是照片在动,是一个人站立然后抬起左手,然后又放下的动作.<h3>细节</h3><p>上述是三张照片,可以看到这个人抬左手的动作,如果想看清楚这个人抬起左手的细节,比如抬起时手心在哪,抬起的角度等等,那么有一个办法<p>就是增加照片数量.可以让这人将抬手动作做得很慢,每抬起一点距离就拍张照片,如此一来可能得到几十张照片.然后将这些照片轮播,此时观看<p>者感觉到这人的抬手动作比较生动能看到过程.<h3>摄像</h3><p>上面的办法要求这个人做慢的抬手动作,显然需要有一个变通的办法.就是这个人正常抬手,在拍照时增加频率.简单的说就是在这人抬手动作<p>过程中,快速的拍照,直到动作完成.那么这样就得到更多的照片.这个过程可叫做摄像,可以认为摄像机在摄像时,其实是在不停的拍照片<h3>帧</h3><p>摄像过程本质上是拍了很多照片,这些照片可以按某种格式组成一个文件,例如"抬手动画.mp4".那么其中一张照片叫做帧.<p>这里有个问题,摄像时频率多少合适.如果太高,那么得到的照片很多,文件很大,虽然动作更细腻但太高时人眼也感觉不出了.而太少的话,文件较小<p>但是动作跨度大,很生硬.显然过多过少都不合适.那么可以设定一个频率,是60.也就是说每秒钟拍摄60张照片比较适宜.</p><canvas id=canvas1></canvas><h2>window.requestAnimationFrame()</h2><p>浏览器用于动画的方法是window.requestAnimationFrame(callback); 参数是一个方法引用,此方法就是绘图方法.对应的还有window.cancelAnimationFrame()<p>前者调用动画函数,返回值是一个long整数,后者传入这个数可以取消动画.这两个方法是专门为动画而造的.<p>window.setInterval() 和 window.setTimeout() 两个方法也可做动画,但这两方法并不是因为动画而造的.它们是通用的方法,用于定时指行程序<p>文档参考 <a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame target=_blank>https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a><p>回调函数(callback)会被传入DOMHighResTimeStamp参数,DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间.<p>在同一个帧中的多个回调函数,它们每一个都会接受到一个相同的时间戳,即使在计算上一个回调函数的工作负载期间已经消耗了一些时间.<p>该时间戳是一个十进制数,单位毫秒,最小精度为1ms(1000μs).<pre class=bg-gray-lt>

  // 动画函数
  function ani(timestamp){

    // 完成一次动画后,再次调用动画函数,才可以实现连续动画
    window.requestAnimationFrame(ani);

    // 可以每次停顿一秒钟,执行一次动画
    setTimeout(() => {
          window.requestAnimationFrame(ani);
    }, 1000)
  }
  // 调用动画函数
  window.requestAnimationFrame(ani)

</pre><br><h3>其它书签</h3><p>(237页)<p>动画<p>(248页)<p>帧速率的计算逻辑<p>(270页)<p>动画制作最佳指导原则<p>(273页)<p>精灵对象<p>(340页)<p>碰撞检测,分离轴定理<p>(344页)<p>确定投影轴<p>(362页)<p>最小平移量 MTV<h2>直线运动</h2><p>直线运动比较简单,模拟物体在画布上的直线运动,使用s=vt位移公式,求出每时刻位置,然后绘画出来.距离单位米和画布单位像素设定比例100px=1米<h3>匀速直线运动</h3><p>长方形物体匀速直线运动,物体长宽 1*0.3, 速度 0.2m/s , 中心点从画布0px位置开始,移动到300px位置,如此重复<p>关键计算是,由DOMHighResTimeStamp参数计算出每一帧的时间间隔,然后0.2m/s要换算成 0.2 * interval / 1000 ,timeStamp参数单位是<p>毫秒,然后再累加移动距离,得到当前X轴位置,绘画.下图每走一圈,速度加0.1,加到1再重置为0.2</p><canvas id=canvas2></canvas><h3>匀加速直线运动</h3><p>加速度: 0.2m/平方s</p><canvas id=canvas3></canvas><h3>匀速圆周运动</h3><canvas id=canvas4></canvas><br><hr class=line><script src=/cavlib/cavlib.js></script><script>function test4(){let e=cavlib("canvas4").style(),n=e.ctx;n.font="16px serail";n.translate(150,75);let i=Math.PI/5,r=50,o=i*180/Math.PI+"°/s",t=0,u=0,f=e=>{t+=e-u;u=e;n.clearRect(-150,-75,300,150);n.beginPath();n.arc(0,0,2,0,Math.PI*2);n.fillStyle="red";n.fill();n.beginPath();n.strokeStyle="black";let s=i*t/1e3,h=r*Math.cos(s),c=r*Math.sin(s),l=60,a=20,v=h-l/2,y=c-a/2;n.rect(v,y,l,a);n.stroke();n.fillText(o,h-20,c+5);n.beginPath();n.moveTo(0,0);n.lineTo(h,c);n.strokeStyle="blue";n.stroke();s>Math.PI*2&&(t=0);window.requestAnimationFrame(f)};window.requestAnimationFrame(f)}function test3(){let f=cavlib("canvas3").style(),t=f.ctx;t.font="16px serail";t.textBaseline="middle";t.textAlign="center";let n=newPlayer();n.x0=0;n.y0=70;n.x1=300;n.y1=70;n.aSpeed=20;let i=0,r=0,u=f=>{i+=f-r,r=f,t.clearRect(0,0,300,150),n.runAt(t,i),n.isEnd()&&(n.reset(),i=0),window.requestAnimationFrame(u)};window.requestAnimationFrame(u)}function test2(){let s=cavlib("canvas2").style(),i=s.ctx;i.font="16px serail";i.textBaseline="middle";i.textAlign="center";let n=newPlayer();n.x0=0;n.y0=70;n.x1=300;n.y1=70;n.speed=20;let r=0,f=0,t=new newPlayer;t.x0=0;t.y0=30;t.x1=300;t.y1=150;t.speed=45;let u=0,e=0,o=s=>{r+=s-f,f=s,u+=s-e,e=s,i.clearRect(0,0,300,150),n.runVt(i,r),t.runVt(i,u),n.isEnd()&&(n.reset(),n.speed+=10,n.speed>100&&(n.speed=20),r=0),t.isEnd()&&(t.reset(),u=0),window.requestAnimationFrame(o)};window.requestAnimationFrame(o)}function newPlayer(){let n={};return n.x=0,n.y=0,n.x0=0,n.y0=0,n.x1=0,n.y1=0,n.width=100,n.height=30,n.speed=0,n.aSpeed=0,n.scale=100,n.isEnd=()=>n.x>n.x1,n.reset=()=>{},n.sVt=t=>n.speed*t/1e3,n.sAt=t=>{let i=t/1e3;return 1/2*n.aSpeed*i*i},n.currXY=t=>{let i=getPointDistA(n.x0,n.y0,n.x1,n.y1,t);n.x=i[0];n.y=i[1]},n.draw=t=>{t.beginPath(),t.fillStyle="black",t.fillRect(n.x-n.width/2,n.y-n.height/2,n.width,n.height),t.fillStyle="white"},n.runVt=(t,i)=>{let r=n.sVt(i);n.currXY(r);n.draw(t);t.fillText(n.speed/n.scale+"m/s",n.x,n.y)},n.runAt=(t,i)=>{let r=n.sAt(i);n.currXY(r);n.draw(t);t.fillText(n.aSpeed/n.scale+"m/s*s",n.x,n.y)},n}function getPointDistA(n,t,i,r,u){if(n===i){const i=t+(t>r?-u:u);return[n,i]}if(t===r){const r=n+(n>i?-u:u);return[r,t]}let o=(r-t)/(i-n),f=translatePoint(u,0,-n,-t),e=rotatePoint(f.x,f.y,Math.atan(-o));return[e.x,e.y]}function test1(){let e=cavlib("canvas1").style(),n=e.ctx;n.fillRect(250,0,50,150);n.fillStyle="red";let t=0,r=randInt(10,140),i=randInt(1,8),u=randInt(5,15),f=()=>{if(n.clearRect(0,0,250,150),n.beginPath(),n.arc(t,r,u,0,Math.PI*2),n.fill(),t+=i,t>randInt(250+i,300)){t=0;r=randInt(10,140);i=randInt(1,8);u=randInt(5,15);let f=randInt(0,256),e=randInt(0,256),o=randInt(0,256);n.fillStyle=`rgb(${f},${e},${o})`}window.requestAnimationFrame(f)};window.requestAnimationFrame(f)}function randInt(n,t){let i=Math.random()*(t-n);return Math.floor(i)+n}function translatePoint(n,t,i,r){let u=n-i,f=t-r;return{x:u,y:f}}function rotatePoint(n,t,i){let r=n*Math.cos(i)+t*Math.sin(i),u=t*Math.cos(i)-n*Math.sin(i);return{x:parseFloat(r.toFixed(4)),y:parseFloat(u.toFixed(4))}}test1();test2();test3();test4()</script></div><div class=nav-page-inside><h6 class=text-center>本文内容</h6><div class=layout-v id=navOfInPage></div></div></div></div><script src=/asset/js/mainmenu.js></script><script src=/asset/js/navinpage.js></script>