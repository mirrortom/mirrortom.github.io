<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>圆 | canvas-demo | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class=layout-part2><h2>圆</h2><p>圆是2次曲线,平面上所有到定点距离相等的点的轨迹是圆形.<p>圆是圆锥曲线,用平行于圆锥底面的平面截取得到.</p><canvas id=canvas1></canvas><h4>求两个圆的交点</h4><p>两个圆如果相交,会有两个交点.如果相切,会有一个交点.</p><canvas id=canvas2></canvas><p>交点可以通关联两个圆的方程组求解得到,但是这个方法比较费劲.可以利用相交圆的性质便捷的求出交点.<h5>切点</h5><p>两个圆相切时有一个交点,根据相切的性质,两个圆的切线点位于两个圆心连线上,切线垂直于圆心连线</p><canvas id=canvas3></canvas><p>如上图: o1 , o2 是圆心, D 是切点.<p>那么已知条件有 o1 , o2 坐标, o1D = o1.r, o2D = o2.r , λ = o1D / Do2 = o1.r / o2.r<p>这就可以使用定比分点公式求出 D 的坐标.<pre class=bg-gray>
    x = (x1 + λ * x2) / (1 + λ)

    y = (y1 + λ * y2) / (1 + λ)

</pre><h5>交点</h5><p>两个圆相交,会有2个交点,其连线是两个圆共有的一条弦.<p>根据公共弦的性质,圆心连线垂直平分公共弦.</p><canvas id=canvas4></canvas><p>以上图推导计算交点坐标的公式,这是个特例,圆心的连线与 X 轴平行.且原点是 o1 .<pre class=bg-gray>
    // 设 
    o1o2 = M , o1D = x , AD = y , o1.r = r1 , o2.r = r2

    // 由于 AB 垂直 o1o2,且被 o1o2 平分.所以 AD = DB
    // 根据直角三角形 a^2 + b^2 = c^2 有
    x^2 = r1^2 - y^2
    (M - x)^2 = r2^2 - y^2

    // 解出 x
    x = (r1^2 - r2^2 + M^2) / 2M

    // 带入第一个方程解出 y , y 和 -y 就是两个点的 y 坐标.

    // 这个公式计算出的坐标值,是以 r1 为原点,o1o2 为 X 轴正方向的坐标系的.
    // 注意,作为原点的 r1 需要是 r1,r2 圆心的 x 坐标值较小的那个,
    // 如果r1,r1圆心的 x 值相同,那么 r1 是 y 坐标值较小的那个.

    // 公式计算出的坐标值,要换算回原来的坐标系值,需要做一次旋转变换,和平移变换.
    // 旋转变换角度就是 o1o2 的斜率对应角度,如果是垂直 X 轴的,角度是 -Math.PI/2
    // 平移变换就是 r1 的圆心为参考点.

</pre><p>得到坐标后,根据<a href=transfer.html target=_blank>坐标系变换公式</a>,再求出其在原坐标系的坐标.<p>虽然要变换坐标系,但是比起解两个圆的方程,计算要简便.<p>经过测试,在以下情况结果都正确</p><canvas id=canvas5></canvas><hr class=line><script src=/jslib/cavlib.js></script><script>(()=>{function t(){var r,f;let e=cavlib.cirs,o=cavlib("canvas5").style(),n=o.ctx;n.canvas.width=600;n.canvas.height=400;n.font="16px serial";let t=30,i=45,u=[{x:40,y:60,r:t},{x:90,y:60,r:i},{x:175,y:60,r:t},{x:200,y:60,r:i},{x:355,y:60,r:t},{x:300,y:60,r:i},{x:480,y:60,r:t},{x:455,y:60,r:i},{x:60,y:150,r:t},{x:60,y:190,r:i},{x:180,y:170,r:t},{x:180,y:190,r:i},{x:320,y:220,r:t},{x:320,y:170,r:i},{x:460,y:200,r:t},{x:460,y:170,r:i},{x:50,y:290,r:t},{x:100,y:310,r:i},{x:250,y:310,r:t},{x:210,y:290,r:i},{x:320,y:340,r:t},{x:380,y:320,r:i},{x:500,y:290,r:t},{x:480,y:305,r:i}];for(r=0,f=u.length;r<f;r++){let t=u[r];n.beginPath();n.arc(t.x,t.y,t.r,0,Math.PI*2);n.strokeStyle=r%2==0?"orangered":"green";n.stroke();n.beginPath();n.fillStyle=r%2==0?"orangered":"green";n.arc(t.x,t.y,2,0,Math.PI*2);n.fill()}for(r=0,f=u.length;r<f;r+=2){let i=u[r],f=u[r+1];n.beginPath();n.strokeStyle="black";n.moveTo(i.x,i.y);n.lineTo(f.x,f.y);n.stroke();let t=e.getCrossLine(i,f);t!=null&&(n.beginPath(),n.strokeStyle="blue",n.moveTo(t.x1,t.y1),n.lineTo(t.x2,t.y2),n.stroke())}}function i(){var i,u;let f=cavlib("canvas4").style(),t=f.ctx;t.font="16px serial";let r=[{x:105,y:85,r:50,c:"blue"},{x:160,y:85,r:40,c:"green"}];for(i=0,u=r.length;i<u;i++){let n=r[i];t.beginPath();t.arc(n.x,n.y,n.r,0,Math.PI*2);t.strokeStyle=n.c;t.stroke();t.beginPath();t.fillStyle="red";t.arc(n.x,n.y,n.r/20,0,Math.PI*2);t.fill();t.fillText("O"+[i+1],n.x,n.y-10)}for(i=0,u=r.length;i<u;i+=2){let f=r[i],e=r[i+1];t.beginPath();t.strokeStyle="black";t.moveTo(f.x,f.y);t.lineTo(e.x,e.y);t.stroke();let o=n.getTangent(f,e);t.fillStyle="skyblue";t.arc(o.x,o.y,4,0,Math.PI*2);t.fill();t.fillStyle="black";t.fillText("D",o.x+5,o.y+20);let u=n.getCrossLine(f,e);t.beginPath();t.strokeStyle="orangered";t.moveTo(u.x1,u.y1);t.lineTo(u.x2,u.y2);t.stroke();t.fillText("A",u.x2-5,u.y2-15);t.fillText("B",u.x1-5,u.y1+20);t.restore()}}function r(){let o=cavlib("canvas3").style(),t=o.ctx;t.font="16px serial";let r=[{x:115,y:95,r:40,c:"brown"},{x:151,y:35,r:30,c:"orange"}];for(var u=0,s=r.length;u<s;u++){let n=r[u];t.beginPath();t.arc(n.x,n.y,n.r,0,Math.PI*2);t.strokeStyle=n.c;t.stroke();t.beginPath();t.fillStyle="red";t.arc(n.x,n.y,n.r/20,0,Math.PI*2);t.fill();t.fillText("O"+[u+1],n.x,n.y-10)}let f=r[0],e=r[1];t.beginPath();t.strokeStyle="blue";t.moveTo(f.x,f.y);t.lineTo(e.x,e.y);t.stroke();let i=n.getTangent(f,e);i!=null&&i.istag==!0&&(t.beginPath(),t.fillStyle="black",t.arc(i.x,i.y,4,0,Math.PI*2),t.fill(),t.fillText("D",i.x+10,i.y))}function u(){var i,u;let f=cavlib("canvas2").style(),t=f.ctx,r=[{x:85,y:75,r:60,c:"red"},{x:55,y:65,r:50,c:"green"},{x:215,y:96,r:40,c:"blue"},{x:249.3,y:35,r:30,c:"orange"}];for(i=0,u=r.length;i<u;i++){let n=r[i];t.beginPath();t.arc(n.x,n.y,n.r,0,Math.PI*2);t.strokeStyle=n.c;t.stroke()}for(i=0,u=r.length;i<u;i+=2){let e=r[i],o=r[i+1],f=n.getTangent(e,o);if(f!=null&&f.istag==!0){t.beginPath();t.arc(f.x,f.y,4,0,Math.PI*2);t.fill();continue}let u=n.getCrossLine(e,o);u!=null&&(t.fillStyle="black",t.beginPath(),t.arc(u.x1,u.y1,4,0,Math.PI*2),t.fill(),t.beginPath(),t.arc(u.x2,u.y2,4,0,Math.PI*2),t.fill())}}function f(){let i=cavlib("canvas1").style(),t=i.ctx,n={x:150,y:75,r:60};t.beginPath();t.arc(n.x,n.y,n.r,0,Math.PI*2);t.stroke();t.beginPath();t.arc(n.x,n.y,n.r/20,0,Math.PI*2);t.fill();t.beginPath();t.strokeStyle="blue";t.moveTo(n.x+n.r,n.y);t.lineTo(n.x,n.y);t.lineTo(n.x,n.y+n.r);t.stroke()}let n=cavlib.cirs,e=cavlib.line;f();u();r();i();t()})(window)</script></div></div><script src=/asset/js/mainmenu.js></script>