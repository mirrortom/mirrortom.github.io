<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><title>restore | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>restore()</h2><p>回退到上一次save()调用前的状态<pre class="bg-gray pd-tb-10">
  ctx.restore()
</pre><br><h4>测验</h4><p>回退到<a href=save.html>save()</a>之前的状态</p><canvas id=canvas1></canvas><h5>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> 第8~9页</h5><p>将canvas状态堆栈顶部的一组状态弹出,原来保存于栈顶的那一组状态,在弹出之后,就被设置成canvas当前的状态了,规范书规定,浏览器必须<p>要根据此值来设定canvas的对应属性.因此,在调用save()与restore()方法之间,对canvas状态所进行的修改,其效果只会持续至restore()方法被调用之前</p><script src=/jslib/cavlib.js></script><script>function test1(){let t=cavlib("canvas1").style(),n=t.ctx;n.save();n.translate(20,30);n.rotate(Math.PI/6);n.strokeStyle="red";n.arc(110,20,20,0,Math.PI*2);n.font="18px serial";n.fillStyle="green";n.fillText("旋转30度,原点修改为20,30",10,10);n.stroke();n.restore();n.fillRect(200,10,40,45);n.fillText("restore()后,回复了原样",180,80);n.stroke()}test1()</script></div></div><script src=menu.js></script>