<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><title>clip | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>clip()</h2><p>将剪辑区域设置为当前路径区域与已有剪辑区域的交集.canvas画布其实是一个剪辑区域,此方法能再次设定剪辑区域,此方法的效果是叠加的.<p>设定剪辑区域后,绘画效果只出现在剪辑区内.<pre class="bg-gray pd-tb-10">
  ctx.clip();
</pre><br><h4>测验</h4><p>在画布中心画一个三角形,当做剪辑区域,然后fill整个画布.如下图,并没有填充整个画布,而只填充三角形.因为绘制效果只会影响剪辑区域.</p><canvas id=canvas1></canvas><script src=/jslib/cavlib.js></script><script>function test1(){let r=cavlib("canvas1").style(),n=r.ctx;n.font="22px serial";n.moveTo(150,30);n.lineTo(50,140);n.lineTo(200,140);n.closePath();n.clip();let t=0,i=()=>{n.clearRect(0,0,300,150),n.fillStyle="black",n.fillRect(0,0,300,150),n.fillStyle="white",n.fillText("Clip 剪辑区域",t,125),t++,t>300&&(t=0),window.requestAnimationFrame(i)};window.requestAnimationFrame(i)}test1()</script></div></div><script src=menu.js></script>