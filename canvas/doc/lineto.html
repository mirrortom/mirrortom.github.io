<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><title>lineto | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>lineTo(x, y)</h2><p>使用直线连接子路径的终点到x,y坐标的方法,并不会真正地绘制<pre class="bg-gray pd-tb-10">
  ctx.lineTo(x, y)
</pre><h4>参数</h4><p><label class="label danger">x</label> <small>Number</small> 直线终点的 x 轴坐标<p><label class="label danger">y</label> <small>Number</small> 直线终点的 y 轴坐标</p><br><h4>测验</h4><p><a href=moveto.html>moveTo()</a>是在移动画笔,而lineTo()则是在走过路径.<p>连续的moveTo()和lineTo()画出一组平行线</p><canvas id=canvas1></canvas><p>不使用moveTo(),连续两次使用lineTo(),可见效果与先使用moveTo()再使用lineTo()效果相同</p><canvas id=canvas2></canvas><h5>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> 70页</h5><p>lineTo()方法,如果当前路径中没有子路径,那么此方法与<a href=moveto.html>moveTo()</a>一样,创建新的子路径.如果有子路径<p>那么将传入的点加入到子路径中</p><script src=/cavlib/cavlib.js></script><script>function test2(){let t=cavlib("canvas2").style(),n=t.ctx;n.lineTo(20,20);n.lineTo(200,129);n.stroke()}function test1(){let i=cavlib("canvas1").style(),t=i.ctx;for(var n=0;n<6;n++)t.moveTo(10+n*10,n*20+10),t.lineTo(200+n*10,n*20+10);t.stroke()}test1();test2()</script></div></div><script src=/asset/js/canvasapimenu.js></script>