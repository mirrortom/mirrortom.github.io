<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><title>arcto | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>arcTo(x1, y1, x2, y2, radius)</h2><p>根据控制点和半径绘制圆弧路径,使用当前的描点(前一个moveTo或lineTo等函数的止点).根据当前描点与给定的控制点1连接的直线,和控制点1与控制点2连接的直线,作为使用指定半径的圆的切线,画出两条切线之间的弧线路径.<pre class="bg-gray pd-tb-10">
  ctx.arcTo(x1, y1, x2, y2, radius)
</pre><br><h4>参数</h4><p><label class="label danger">x1</label> <small>Number</small> 第1个控制点x坐标<p><label class="label danger">y1</label> <small>Number</small> 第1个控制点y坐标<p><label class="label danger">x1</label> <small>Number</small> 第2个控制点x坐标<p><label class="label danger">y1</label> <small>Number</small> 第2个控制点y坐标<p><label class="label danger">radius</label> <small>Number</small> 圆弧的半径大小.</p><br><h4>测验</h4><p>这个方法的说明看得不太明白,简要的讲就是有三个点,连接成两条线段,调用此方法后能画出一段圆弧,且是与这两条线段相切的.<p>arcTo()方法接收两个点坐标参数,是为控制点1和控制点2,还需要一个起点,这就是上次调用moveTo或lineTo之后的那个点.<p>这里有些不解,为什么要是最后moveTo为起点,直接弄三个参数就行了啊.就像arcTo(起x,起y,x1,y1,x2,y2,r)<p>另外,ps里也有这个功能,钢笔工具也能画这样的圆弧.</p><canvas id=canvas1></canvas><p>三个点的位置和半径影响圆弧的样子,如果点位控制得不佳,有可能圆弧如下.<p>除了圆弧,还有一个线段,可以看出线段与圆弧的分界点是起点与控制点1的相切点</p><canvas id=canvas2></canvas><script src=/jslib/cavlib.js></script><script>function test2(){let u=cavlib("canvas2").style(),n=u.ctx,t={x:20,y:30},i={x:230,y:30},r={x:50,y:120};n.beginPath();n.canvas.width=500;n.font="18px serial";n.moveTo(t.x,t.y);n.arcTo(i.x,i.y,r.x,r.y,35);n.stroke();n.beginPath();n.fillStyle="black";n.arc(t.x-2,t.y,5,0,Math.PI*2);n.fillText("上次moveTo或lineTo的点",t.x,t.y-10);n.fill();n.beginPath();n.arc(i.x+2,i.y+2,5,0,Math.PI*2);n.fillText("控制点1",i.x+10,i.y+5);n.fill();n.beginPath();n.arc(r.x-2,r.y-2,5,0,Math.PI*2);n.fillText("控制点2",r.x+10,r.y);n.fill()}function test1(){let u=cavlib("canvas1").style(),n=u.ctx;n.canvas.width=500;n.font="18px serial";let t={x:200,y:20},i={x:130,y:120},r={x:50,y:20};n.beginPath();n.strokeStyle="red";n.fillStyle="red";n.moveTo(t.x,t.y);n.arcTo(i.x,i.y,r.x,r.y,50);n.fillText("圆弧与这两线相切",t.x-20,80);n.stroke();n.beginPath();n.strokeStyle="green";n.moveTo(t.x,t.y);n.lineTo(i.x,i.y);n.lineTo(r.x,r.y);n.stroke();n.beginPath();n.fillStyle="black";n.arc(t.x-2,t.y,5,0,Math.PI*2);n.fillText("上次moveTo或lineTo的点",t.x,t.y);n.fill();n.beginPath();n.arc(i.x+2,i.y+2,5,0,Math.PI*2);n.fillText("控制点1",i.x+10,i.y+5);n.fill();n.beginPath();n.arc(r.x-2,r.y-2,5,0,Math.PI*2);n.fillText("控制点2",r.x+10,r.y);n.fill()}test1();test2()</script></div></div><script src=/asset/js/canvasapimenu.js></script>