<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><title>putImageData | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>putImageData()</h2><p>将一个矩形区域的像素绘制到画布上<pre class="bg-gray pd-tb-10">
  ctx.putImageData(imagedata, dx, dy);
  ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
</pre><h4>参数</h4><p><label class="label danger">imageData</label> <small>ImageData</small> 包含像素值的数组对象<p><label class="label danger">dx</label> <small>Number</small> 源图像数据在目标画布中的位置偏移量（x 轴方向的偏移量）.<p><label class="label danger">dy</label> <small>Number</small> 源图像数据在目标画布中的位置偏移量（y 轴方向的偏移量）.<p><label class="label danger">dirtyX</label> <small>Number</small> 在源图像数据中,矩形区域左上角的位置.默认是整个图像数据的左上角（x 坐标）.<p><label class="label danger">dirtyY</label> <small>Number</small> 在源图像数据中,矩形区域左上角的位置.默认是整个图像数据的左上角（y 坐标）.<p><label class="label danger">dirtyWidth</label> <small>Number</small> 在源图像数据中,矩形区域的宽度.默认是图像数据的宽度.<p><label class="label danger">dirtyHeight</label> <small>Number</small> 在源图像数据中,矩形区域的高度.默认是图像数据的高度.</p><br><h4>测验</h4><p>putImageData(imagedata, 10, 10)<p>从左图中使用<a href=getimagedata.html>getImageData()</a>获取ImageData对象,画到右图中<div class=grids><canvas id=canvas1></canvas><canvas id=canvas2></canvas></div><p>putImageData(imagedata, 10, 10, 0, 0, 50, 50)<p>与<a href=drawimage.html>drawImage()</a>类似,从imagedata中选出一部分画到画布上</p><canvas id=canvas3></canvas><p>&lt;&lt;H5核心技术图形动画与游戏开发(David Geary)>> 194页<p>putImageData()方法不受全局设置的影响.这与drawImage()方法正好相反</p><script src=/cavlib/cavlib.js></script><script>function test3(){let n=cavlib("canvas1").style(),t=n.ctx,i=cavlib("canvas3").style(),r=i.ctx,u=t.getImageData(100,40,150,80);r.putImageData(u,10,10,0,0,50,50)}function test2(){let n=cavlib("canvas1").style(),t=n.ctx,i=cavlib("canvas2").style(),r=i.ctx,u=t.getImageData(100,40,150,80);r.putImageData(u,10,10)}function test1(){let i=cavlib("canvas1").style(),n=i.ctx;n.fillStyle="gray";n.fillRect(0,0,300,150);n.translate(150,75);n.rotate(Math.PI/4);n.fillStyle="#ff00ff";for(var t=-20;t<15;t++)t%2==0&&n.fillRect(-160,10*t,320,10)}test1();test2();test3()</script></div></div><script src=/asset/js/canvasapimenu.js></script>