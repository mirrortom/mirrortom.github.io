<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><title>ellipse | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)</h2><p>椭圆的圆心在（x,y）位置,半径分别是radiusX 和 radiusY ,按照anticlockwise（默认顺时针）指定的方向,从 startAngle 开始绘制,到 endAngle 结束.<pre class="bg-gray pd-tb-10">
  ctx.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise)
</pre><br><h4>参数</h4><p><label class="label danger">x</label> <small>Number</small> 椭圆圆心的 x 轴坐标<p><label class="label danger">y</label> <small>Number</small> 椭圆圆心的 y 轴坐标<p><label class="label danger">radiusX</label> <small>Number</small> 椭圆长轴的半径<p><label class="label danger">radiusY</label> <small>Number</small> 椭圆短轴的半径<p><label class="label danger">rotation</label> <small>Number</small> 椭圆的旋转角度,以弧度表示<p><label class="label danger">startAngle</label> <small>Number</small> 将要绘制的起始点角度,从 x 轴测量,以弧度表示<p><label class="label danger">endAngle</label> <small>Number</small> 椭圆将要绘制的结束点角度,以弧度表示(非角度度数)<p><label class="label danger">anticlockwise</label> <small>Number</small> Boolean 选项,如果为 true,逆时针方向绘制椭圆 （逆时针）, 反之顺时针方向绘制</p><br><h4>测验</h4><p>圆心,长轴,短轴.三个参数与几何上椭圆定义不同,几何上椭圆有两个焦点,长轴,短轴是椭圆内最长和最短的线段<p>这三个参数与几何定义的关系可能是,圆心是两焦点的中点,长轴与短轴同几何中长轴和短轴的一半</p><canvas id=canvas1></canvas><p>旋转角度,下图为30度旋转效果.可见顺时针旋转30度后,长轴与X轴有夹角30度.<p>开始角度与结束角度和<a href=arc.html>arc()</a>方法一样,0到360时是整个椭圆,否则只有椭圆的一部分</p><canvas id=canvas2></canvas><script src=/jslib/cavlib.js></script><script>function test2(){let r=cavlib("canvas2").style(),n=r.ctx,i={x:120,y:72},t=85;n.translate(i.x,i.y);n.ellipse(0,0,t,60,Math.PI/6,0,Math.PI*2);n.stroke();n.beginPath();n.strokeStyle="green";n.moveTo(0,0);n.lineTo(150,0);n.moveTo(0,0);n.lineTo(0,75);n.stroke();n.save();n.beginPath();n.rotate(Math.PI/6);n.moveTo(0,0);n.lineTo(t,0);n.stroke();n.restore();n.beginPath();n.arc(0,0,30,0,Math.PI/6);n.stroke();n.fillText("30度",t/2,20)}function test1(){let u=cavlib("canvas1").style(),n=u.ctx,r={x:120,y:72},t=85,i=60;n.translate(r.x,r.y);n.ellipse(0,0,t,i,0,0,Math.PI*2);n.stroke();n.font="18px serial";n.fillStyle="red";n.beginPath();n.arc(0,0,3,0,Math.PI*2);n.fill();n.fillText("x,y",-t/3,-8);n.moveTo(0,0);n.lineTo(t,0);n.fillText("长轴",t/3,-5);n.moveTo(0,0);n.lineTo(0,i);n.fillText("短轴",5,i/2);n.stroke()}test1();test2()</script></div></div><script src=menu.js></script>