<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><title>beginPath | canvas文档整理 | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.mainmenubox{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}</style><div class=page><div class=mainmenubox id=mainmenubox></div><div class=pd-20><h2>beginPath()</h2><p>新建一条路径,生成之后,图形绘制命令被指向到路径上生成路径.无参数,调用方法后,新路径开始.之前的路径会清空.<pre class="bg-gray pd-tb-10">
  ctx.beginPath();
</pre><br><h4>测验</h4><p>画两个矩形,红色和绿色,不使用beginPath().效果不是预期的,并且第2个矩形是绿色,但前一个不是红色,像是先红再绿的叠加色<p>画第1个矩形时,使用了红色,然后调用<a href=stroke.html>stroke()</a>,画第2个矩形时,使用绿色,再次调用stroke().此时第二个stroke()会对之前<p>所有路径生效.也就是说,第1个矩形本来是红色的,然后又涂了一次绿色,结果变成像驴粪一样的颜色</p><canvas id=canvas1></canvas><p>在两次stroke()之前,都调用beginPath()的效果是达到预期的.<p>可以说明,stroke()影响的路径范围,是在beginPath()之后.那么当画完红色矩形之后,由于新起了路径,所以画绿矩形时,stroke()<p>并不会影响红色矩形,因为此时的路径范围是在红色矩形画完后,调用beginPath()之后的.</p><canvas id=canvas2></canvas><p>连续画两个弧线,中间不使用beginPath(),结果是,前一次弧线的终点与后一次弧线的起点直线相连</p><canvas id=canvas3></canvas><h3>应用</h3><p>每次在画布上绘制时,应该使用此方法,特别是在互不相干的绘制时,要调用此方法.避免路径混淆.</p><script src=/jslib/cavlib.js></script><script>function test3(){let t=cavlib("canvas3").style(),n=t.ctx;n.font="18px serial";n.arc(50,40,40,0,Math.PI);n.arc(200,60,40,0,Math.PI/3,!0);n.stroke();n.fillText("弧线1终点",0,30);n.fillRect(6,35,8,8);n.fillText("弧线2起点",200,80);n.fillRect(235,55,8,8)}function test1(){let t=cavlib("canvas1").style(),n=t.ctx;n.strokeStyle="red";n.rect(20,20,200,60);n.stroke();n.strokeStyle="green";n.rect(50,50,200,60);n.stroke()}function test2(){let t=cavlib("canvas2").style(),n=t.ctx;n.beginPath();n.strokeStyle="red";n.rect(20,20,200,60);n.stroke();n.beginPath();n.strokeStyle="green";n.rect(50,50,200,60);n.stroke()}test1();test2();test3()</script></div></div><script src=/asset/js/canvasapimenu.js></script>