<div class=doc-page><h2>rotate(angle)</h2><p>旋转坐标系angle弧度<pre>
  ctx.rotate(angle)
</pre><br><h4>参数</h4><p><b class=txt-sky-4>angle</b> <small>Number</small> 要旋转的弧度值,正值顺时针旋转,负值逆时针旋转</p><canvas id=canvas4></canvas><br><h4>测验</h4><p>画一条水平线,(50,25)(130,25),旋转画布45度后,计算其坐标.计算公式如下:<p>x = x*cos(A) - y*sin(A) , y = y*cos(A) + x*sin(A)</p><canvas id=canvas1></canvas><p>旋转坐标45度(Math.PI/4)后,再画这条线.继续再转30度,再画(红色线)</p><canvas id=canvas2></canvas><p>可以看到,每次调用rotate(angle),都是基于之前旋转后叠加的.这个例子,先转45度,画线后,对于未转前,有45度的倾斜<p>再转30度后,相到于原画布转了45+30=75度,发现线(红色线)再度倾斜了,但线未完全画出,只有一部分<p>画布顺时针转动了75度,并且是以原点为心转动的,此时画布的一部分已经转到左侧去了,不在canvas元素范围内了.<p>所以只看到一部分的红色线<p>参数为负值时,逆时针转动</p><canvas id=canvas3></canvas><br><h3>简化坐标</h3><p>活用这个功能,可以大幅减少复杂的坐标计算.主要是基于角度变化时坐标需要重新计算.<p>默认是绕(0,0)点转动,可以配合<a class=goto onclick='mainmenugoto("translate")'>translate()</a>一起使用达到简化坐标计算目的<p>车轮辐辏可以用旋转坐标简化画法,将原点置于车轮圆心,每画一轴旋转一次.画轴线固定为(0,0)(70,0)<p>如果不用此法,需要计算每轴点坐标.需要使用三角函数,这个代码就多一些了</p><canvas id=canvas5></canvas></div><script>function test5(){let i=cavlib("canvas5").style(),n=i.ctx;n.translate(150,75);n.arc(0,0,71,0,Math.PI*2);for(var t=0;t<8;t++)n.moveTo(0,0),n.lineTo(70,0),n.rotate(Math.PI/4);n.stroke()}function test4(){let t=cavlib("canvas4").style(),n=t.ctx;n.arc(0,0,60,0,Math.PI/4);n.font="18px serial";n.fillText("45⁰",60,30);n.fillText("x",280,20);n.moveTo(300,0);n.lineTo(0,0);n.lineTo(0,150);n.stroke();n.beginPath();n.rotate(Math.PI/4);n.fillStyle="lightgreen";n.strokeStyle="red";n.fillRect(0,0,300,150);n.fillText("x",200,-10);n.moveTo(0,0);n.lineTo(300,0);n.stroke()}function test1(){let f=cavlib("canvas1").style(),n=f.ctx,t={x:50,y:25},i={x:130,y:25};n.moveTo(t.x,t.y);n.lineTo(i.x,i.y);n.stroke();n.beginPath();n.arc(t.x,t.y,5,0,Math.PI*2);n.arc(i.x,i.y,5,0,Math.PI*2);n.fill();n.beginPath();n.fillStyle="brown";let r=Math.cos(Math.PI/4),u=Math.sin(Math.PI/4);n.arc(t.x*r-t.y*u,t.y*r+t.x*u,5,0,Math.PI*2);n.arc(i.x*r-i.y*u,i.y*r+i.x*u,5,0,Math.PI*2);n.fill()}function test2(){let t=cavlib("canvas2").style(),n=t.ctx;n.beginPath();n.rotate(Math.PI/4);n.moveTo(50,25);n.lineTo(130,25);n.stroke();n.beginPath();n.rotate(Math.PI/6);n.moveTo(50,25);n.lineTo(130,25);n.strokeStyle="red";n.stroke()}function test3(){let t=cavlib("canvas3").style(),n=t.ctx;n.moveTo(50,125);n.lineTo(130,125);n.stroke();n.rotate(-Math.PI/4);n.moveTo(50,125);n.lineTo(130,125);n.stroke()}test4();test1();test2();test3();test5()</script>