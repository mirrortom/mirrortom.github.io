<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>坐标变换 | canvas-demo | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class=layout-part2><h1>直角坐标系坐标换算</h1><p>同一个点坐标(x,y),在canvas坐标系变换后(点位置不变),计算此点在新坐标系的(x,y)值<p>只研究使用 <a href=doc/translate.html>translate()</a> <a href=doc/rotate.html>rotate()</a> <a href=doc/scale.html>scale()</a>三个方法变换后的坐标系<h3>平移变换</h3><p>p1(80,50) 在默认坐标系中的位置. 坐标轴不是数学的那种,是左上角为顶点的,右和下为正方向</p><canvas id=canvas1></canvas><p>调用translate(150,70)后,p1n点新坐标值位置. 原来p1点的坐标位置.p1与p1n的关系如下<p>p1.x = p1n.x - 150 , p1.y = p1n.y - 70 这是简单的坐标系原点变化.<p>p.x = p0.x - o.x ,p.y = p0.y - o.y (o是新原点坐标)</p><canvas id=canvas2></canvas><h3>旋转变换</h3><p>调用rotate()30度后,p1n与p1.虚线是旋转后的X轴</p><canvas id=canvas3></canvas><p>这个比平移变换复杂些,看下图理解转换关系公式<p>y = y0 * cos(θ) - x0 * sin(θ) ; x = x0 * cos(θ) + y0 * sin(θ)<p>通过计算p点,在原坐标系和新坐标系中的x,y值,推算出x1,y1和x,y的关系.也就是上面的公式.<h4>推演过程</h4><p>1. 坐标系由C0(灰色虚线箭头)旋转θ度,变为C(棕色虚线箭头)<p>2. p点(红色圆点)坐标,在C0坐标系中的(x0,y0)值(蓝色虚线),在C坐标系中的(x,y)值(绿色虚线)<p>3. 由图很直观看出, x = 桔色线段[x0 * cos(θ)] + 红色线段[y0 * sin(θ)] , y = 绿色线段[y0 * cos(θ)] - 天蓝色线段[ x0 * sin(θ)]<p>4. 关键辅助线是两个直角三角形,1是红色线段和绿色线段和蓝色虚线(y0)组成,2是桔色线段和天蓝色线段和蓝色虚线(x0)的平行线组成<p>5. 而这样做辅助线的原理是,要借用C0坐标系已知的(x0,y0)值,还有已知的θ角度.然后便于运用三角函数计算.</p><canvas id=canvas4></canvas><h3>缩放变换</h3><p>调用scale(2,2)后,p1n与p1<p>缩放前后坐标关系是 x = x0 / zoom.x , y = y0 / zoom.y , 这个比较简单,和平移变换类似</p><canvas id=canvas5></canvas><h3>组合变换</h3><p>实际任务中,会组合这三种变换.例如,平移后旋转再放大,或者旋转后放大再平移.<p>这个也不复杂,按照公式就可以求出p点在变换后坐标系的坐标.只是有一点要注意,"变换顺序"<p>下图p1n点的坐标系经过1.平移, 2旋转, 3缩放.那么,还原这些变换后的p1点是怎么求出的<p>1.先平移,得到 pox = p1.x - o.x , poy = p1.x - o.y<p>2.再旋转,prx = pox * cos(θ) + poy * sin(θ) , pry = poy * cos(θ) - pox * sin(θ)<p>3.再缩放,px = prx / zoom.x , py = pry / zoom. y<p>还是依靠公式,不过重要的再说一次,"变换顺序".按照怎样的顺序做的变换,必须要按照相同的顺序用公式.<p>前次用公式算出的坐标值,是其后公式的坐标值参数.所以,顺序是不能乱的.</p><canvas id=canvas6></canvas><h3>矩阵变换</h3><p>canvas矩阵变换方法除了这三个,还有<a href=doc/transform.html>transform()</a>,这个可以设定矩阵参数,一次调用实现组合变换<p>矩阵乘法是不满足交换律的,这也是为什么在求变换后坐标时,不能颠倒顺序的理论依据<h3>同一点位在坐标变换前后的(x,y)值</h3><p>已知点位p(x,y),求该点位在坐标变换后的坐标系中p1(x,y)值.下面分两种情况求点坐标值.<p>1. 点p(50,30),是默认坐标系的点,在平移变换(20,20),旋转变换(30度),缩放变换(1.5,1.5)倍后,新坐标系中的p1(x,y)值<p>2. 点q(50,30),是变换后坐标系的点(变换参数同上),在默认坐标系中的q1(x,y)值</p><canvas id=canvas7></canvas><h3>公式</h3><p>上面两种变换情况的区别在于坐标系参照,假设原坐标系是默认坐标系,记(Z).变换后坐标系是基于Z变换的,记(Z1).那么<p>Z~Z1变换: p(x,y),Z坐标系,在坐标系变换为Z1后,对应位置p1(x,y)的计算公式:<pre>
// 平移变换
p1.x = p.x - Z1.x , p1.y = p.y - Z1.y 

// 旋转变换
p1.y = p.y * cos( θ ) - p.x * sin( θ ) 
p1.x = p.x * cos( θ ) + p.y * sin( θ )

// 缩放变换
p1.x = p.x / zoom.x 
p1.y = p.y / zoom.y 
</pre><br><p>Z1~Z变换: p1(x,y),Z1坐标系,在坐标系变回Z后,对应位置p(x,y)的计算公式:<pre>
// 平移变换
p.x = p1.x - ( - Z1.x ) , p.y = p1.y - ( - Z1.x )
或者 p.x = p1.x + Z1.x  , p.y = p1.y + Z1.x

// 旋转变换
p.y = p1.y * cos( - θ ) - p1.x * sin( - θ ) 
p.x = p1.x * cos( - θ ) + p1.y * sin( - θ )

// 缩放变换
p.x = p1.x / ( 1 / zoom.x )
p.y = p1.y / ( 1 / zoom.y )
或者
p.x = p1.x * zoom.x
p.y = p1.y * zoom.y
</pre><br><p>可见,这两种变换在使用公式时,只需要传入参数的"相反"值.<p>如:平移变换传(-o.x , -o.y),旋转变换传(-angle),缩放变换传(1/zoom.x , 1/zoom.y)</p><script src=/jslib/cavlib.js></script><script>function canva7(){let l=cavlib("canvas7").style(),n=l.ctx;n.font="16px serial";let t={x:50,y:30},r={x:0,y:0},i=Math.PI/6,u={x:1.5,y:1.5};n.arc(t.x,t.y,6,0,Math.PI*2);n.fill();n.fillText(`p(${t.x} , ${t.y})默认坐标系`,t.x,t.y-10);let o=t.x-r.x,s=t.y-r.y,a=o*Math.cos(i)+s*Math.sin(i),v=s*Math.cos(i)-o*Math.sin(i),y=a/u.x,p=v/u.y,e={x:parseFloat(y.toFixed(2)),y:parseFloat(p.toFixed(2))};n.save();n.beginPath();n.translate(r.x,r.y);n.rotate(i);n.scale(u.x,u.y);n.arc(e.x,e.y,2,0,Math.PI*2);n.fillStyle="red";n.fill();n.restore();n.fillStyle="red";n.fillText(`p1(${e.x} , ${e.y})变换后坐标系`,t.x,t.y+20);n.save();n.beginPath();n.translate(r.x,r.y);n.rotate(i);n.scale(u.x,u.y);n.arc(t.x,t.y,4,0,Math.PI*2);n.fillStyle="red";n.fill();n.fillText(`q(${t.x} , ${t.y})`,t.x-10,t.y+20);n.restore();let h=t.x+r.x,c=t.y+r.y,w=h*Math.cos(-i)+c*Math.sin(-i),b=c*Math.cos(-i)-h*Math.sin(-i),k=w*u.x,d=b*u.y,f={x:parseFloat(k.toFixed(2)),y:parseFloat(d.toFixed(2))};n.beginPath();n.fillStyle="black";n.arc(f.x,f.y,3,0,Math.PI*2);n.fill();n.fillText(`q1(${f.x} , ${f.y})默认坐标系`,f.x+10,f.y)}function canva6(){let u=cavlib("canvas6").style(),n=u.ctx,e=450,o=250;n.canvas.width=e;n.canvas.height=o;n.font="16px serial";let i={x:100,y:50},f=Math.PI/6,r={x:1.5,y:1.5},t={x:80,y:50};n.save();n.setLineDash([5]);n.fillStyle="gray";u.lineArrow([0,0,e-50,0]);u.lineArrow([0,0,0,o-60]);n.restore();n.beginPath();n.translate(i.x,i.y);n.rotate(f);n.scale(r.x,r.y);n.arc(t.x,t.y,4,0,Math.PI*2);n.fillStyle="red";n.fill();n.fillStyle="black";n.fillText(`P1n(${Math.floor(t.x)}, ${Math.floor(t.y)})`,t.x-20,t.y-10);n.save();n.setLineDash([5]);n.fillStyle="gray";u.lineArrow([0,0,e-i.x-150,0]);u.lineArrow([0,0,0,o-i.y-80]);n.restore();drawXY(n,t.x,t.y);n.beginPath();let c=t.x-i.x,l=t.y-i.y,a=l*Math.cos(f)-c*Math.sin(f),v=c*Math.cos(f)+l*Math.sin(f),s=v/r.x,h=a/r.y;n.arc(s,h,4/r.x,0,Math.PI*2);n.fillStyle="red";n.fill();n.font=`${16/r.x}px serial`;n.fillText(`P1(${Math.floor(s)}, ${Math.floor(h)})`,s-20,h-10)}function canva5(){let r=cavlib("canvas5").style(),n=r.ctx;n.font="16px serial";let i={x:2,y:2};n.save();n.setLineDash([5]);n.fillStyle="gray";r.lineArrow([0,0,280,0]);r.lineArrow([0,0,0,120]);n.restore();n.beginPath();let t={x:80,y:50};n.fillText(`P1(${Math.floor(t.x/i.x)}, ${Math.floor(t.y/i.y)})`,t.x-20,t.y-10);n.fillStyle="red";n.arc(t.x,t.y,5,0,Math.PI*2);n.fill();n.save();n.beginPath();n.scale(i.x,i.y);n.fillText(`P1n(${t.x}, ${t.y})`,t.x-20,t.y+20);n.fillStyle="red";n.arc(t.x,t.y,5,0,Math.PI*2);n.fill();n.restore();drawXY(n,t.x,t.y);n.save();n.scale(i.x,i.y);drawXY(n,t.x,t.y);n.restore()}function canva4(){let u=cavlib("canvas4").style(),n=u.ctx,f=450,e=250;n.canvas.width=f;n.canvas.height=e;n.font="16px serial";let r={x:100,y:0},i=Math.PI/6,t={x:100,y:150};n.translate(r.x,r.y);n.save();n.setLineDash([5]);n.fillStyle="gray";u.lineArrow([0,0,f-r.x-50,0]);u.lineArrow([0,0,0,e-60]);n.fillText("C0(x0,y0)",f-r.x-80,20);n.restore();n.save();n.rotate(i);n.setLineDash([5]);n.strokeStyle=n.fillStyle="brown";u.lineArrow([0,0,f-r.x-50,0]);u.lineArrow([0,0,0,e-60]);n.fillText("C(x,y)",f-r.x-70,20);n.restore();n.beginPath();n.arc(0,0,25,0,Math.PI/6);n.stroke();n.beginPath();n.fillText("θ",30,15);n.beginPath();n.arc(t.x,t.y,25,Math.PI*3/2,Math.PI*5/3);n.stroke();n.beginPath();n.fillText("θ",t.x+5,t.y-35);n.beginPath();n.fillStyle="red";n.arc(t.x,t.y,5,0,Math.PI*2);n.fill();n.fillStyle="blue";n.fillText("p(x0,y0)",t.x-20,t.y+20);n.fillStyle="green";n.fillText("p(x,y)",t.x-20,t.y+40);drawXY(n,t.x,t.y);n.save();n.rotate(i);let o={x:t.x*Math.cos(i)+t.y*Math.sin(i),y:t.y*Math.cos(i)-t.x*Math.sin(i)};drawXY(n,o.x,o.y,"green");n.restore();n.save();n.lineWidth=2;n.beginPath();n.translate(t.x,0);n.rotate(i);n.moveTo(0,0);n.lineTo(t.y*Math.sin(i),0);n.strokeStyle="red";n.stroke();n.beginPath();n.moveTo(0,t.x*Math.sin(i));n.lineTo(-t.x*Math.cos(i),t.x*Math.sin(i));n.strokeStyle="orange";n.stroke();n.beginPath();n.moveTo(0,0);n.lineTo(0,t.y*Math.cos(i)-o.y);n.strokeStyle="skyblue";n.stroke();n.beginPath();n.moveTo(t.y*Math.sin(i),0);n.lineTo(t.y*Math.sin(i),t.y*Math.cos(i));n.strokeStyle="green";n.stroke();n.restore();n.fillStyle="red";n.fillText("y0 * sin(θ)",t.x+40,20);n.save();n.beginPath();n.rotate(i);n.fillStyle="skyblue";n.fillText("x0 * sin(θ)",t.x*Math.cos(i),-15);n.fillStyle="green";n.fillText("y0 * cos(θ)",t.x*Math.cos(i)+t.y*Math.sin(i)+5,20);n.restore();n.fillStyle="orange";n.fillText("x0 * cos(θ)",0,30)}function canva3(){let u=cavlib("canvas3").style(),n=u.ctx;n.font="16px serial";let r=Math.PI/6;n.rotate(r);let t={x:80,y:50};n.fillText(`P1n(${t.x}, ${t.y})`,t.x-20,t.y-10);n.fillStyle="red";n.fillRect(t.x,t.y,5,5);n.save();n.setLineDash([5]);n.fillStyle="gray";u.lineArrow([0,0,280,0]);n.restore();let i={x:t.x*Math.cos(r)+t.y*Math.sin(r),y:t.y*Math.cos(r)-t.x*Math.sin(r)};n.fillText(`P1(${Math.floor(i.x)}, ${Math.floor(i.y)})`,i.x,i.y-10);n.fillStyle="red";n.fillRect(i.x,i.y,5,5)}function canva2(){let u=cavlib("canvas2").style(),n=u.ctx;n.font="16px serial";let r={x:150,y:70};n.translate(r.x,r.y);let t={x:80,y:50};n.fillText(`P1n(${t.x}, ${t.y})`,t.x-20,t.y-10);n.fillStyle="red";n.fillRect(t.x,t.y,5,5);let i={x:t.x-r.x,y:t.y-r.y};n.fillText(`P1(${i.x}, ${i.y})`,i.x-30,i.y-10);n.beginPath();n.fillStyle="red";n.arc(i.x,i.y,4,0,Math.PI*2);n.fill();n.save();n.setLineDash([5]);n.fillStyle="gray";u.lineArrow([-200,0,100,0],15);u.lineArrow([0,-150,0,50],15);n.restore();drawXY(n,i.x,i.y);n.beginPath();n.fillStyle="gray";n.arc(0,0,4,0,Math.PI*2);n.fill();n.fillStyle="blue";n.fillText("O",5,15)}function canva1(){let i=cavlib("canvas1").style(),n=i.ctx;n.font="16px serial";let t={x:80,y:50};n.fillText(`P1(${t.x}, ${t.y})`,t.x-20,t.y+20);n.beginPath();n.arc(t.x,t.y,4,0,Math.PI*2);n.fillStyle="red";n.fill();n.save();n.setLineDash([5]);n.fillStyle="gray";i.lineArrow([0,0,280,0],15);i.lineArrow([0,0,0,140],15);n.restore();drawXY(n,t.x,t.y);n.fillStyle="blue";n.fillText("O",5,15)}function drawXY(n,t,i,r="blue"){n.save();n.strokeStyle=r;n.setLineDash([5]);n.beginPath();n.moveTo(0,i);n.lineTo(t,i);n.moveTo(t,0);n.lineTo(t,i);n.stroke();n.restore()}canva1();canva2();canva3();canva4();canva5();canva6();canva7()</script></div></div><script src=/asset/js/mainmenu.js></script>