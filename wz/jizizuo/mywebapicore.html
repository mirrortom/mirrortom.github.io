<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>webapi core | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class=layout-part2><div class=wz-page><p><small>2021年4月28日最后修改</small><p>源码 <a href=https://github.com/mirrortom/MyWebApiCore target=_blank>https://github.com/mirrortom/MyWebApiCore</a><div id=mytabs1 class="tabs-box list"><div class=tabs-header><span class=tabs-label>简介</span> <span class=tabs-label>实现</span> <span class=tabs-label>模板</span> <span class=tabs-label>部署</span> <span class=tabs-label>静态</span> <span class=tabs-label>示例</span> <span class=tabs-label>配置</span> <span class=tabs-label>差别</span></div><div class="tabs-panel pd-lr-20"><h3>简介</h3><p>使用 NET5.0 的 SDK Microsoft.NET.Sdk.Web项目.自定义了url解析.为了做一个简单的webapi功能框架.<h5>原理</h5><p>webapi程序依然是要解决三个问题.监听,匹配,处理:监听请求,分析请求地址和参数,响应请求的功能.<p>asp.net core监听请求使用了kestrel服务器,响应请求使用的是"中间件",与经典的asp.net管理事件相似,每个"中件间"就相当于一个处理事件.<p>自定义了分析地址的"中件间"UrlHandler,它分析url,然后指定具体类和方法.<p>自定义了异常时返回信息的"中件间"CustomExceptionHandlerOptions(),当处理发生异常时,如何返回信息.<h5>中间件</h5><p>中间件:"middleware",是处理请求的主要方式,是名为"RequestDelegate"的委托类型.<h5>.net 5</h5><p>core 3.1后,跨域有变化,不允许同时指定AllowAnyOrigin和AllowCredentials,选择去掉AllowCredentials.<p>跨域文档地址: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-3.1#credentials-in-cross-origin-requests" target=_blank>https://docs.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-3.1#credentials-in-cross-origin-requests</a><p>读取kestrel.json的库,Microsoft.Extensions.Configuration.Json,不再包含Newtonsoft.Json库,可以使用自带的System.Text.Json库,或者下载Newtonsoft.Json库<p>netcore3.1后默认禁用了AllowSynchronousIO,获取页面输入流参数时,使用异步方法: Request.Body.ReadAsync()<p>Kestrel传输不再基于Libuv,显示使用nuget包Microsoft.AspNetCore.Server.Kestrel时,服务器不能正常运行.可以添加nuget包Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv 解决,但6.0后不再支持Libuv了.这个项目没由单独使用kestrel了,没这个问题了.</div><div class="tabs-panel pd-lr-20"><h3>实现</h3><h5>主要文件</h5><ul class="list num"><li>ApiHandler类: 用来写自定义的"中间件".按照定义,"中间件"是一个名为RequestDelegate的委托.<li>添加UrlHandler静态方法,用来分析URL,并且映射到具体的处理类上.该方法返回一个"RequestDelegate"委托.<li>添加一个辅助类ApiBase,提供一些便利方法.如取参数,返回结果等<li>[HTTPPOST][HTTPGET][HTTPALL]用于贴在方法上的特性,用于实现一些简单功能,例如区别GET或者POST.不是必要的.<li>kestrel.json: 自带的kestrel web服务器配置文件,配置监听端口和其它选项<li>Program.cs: Main()启动类,用于初始化web主机.含有一系列配置选项.</ul><p>kestrel配置参考这篇文章</p><a href=https://www.cnblogs.com/Leo_wl/p/7875833.html target=_blank>https://www.cnblogs.com/Leo_wl/p/7875833.html</a> <h5>一些约定</h5><p>上述工作弄好之后,就能添加API了.就是添加一个普通的类,做一些约定后就能被访问到了.<ul class="list num"><li>类名以Api结尾<li>类要继承ApiBase<li>类的方法上要贴上特性</ul></div><div class="tabs-panel pd-lr-20"><h3>建立项目</h3><ul class="list num"><li>用VS2017+建一个asp.net core的空项目<li>Microsoft.AspNetCore.Hosting.WindowsServices // 支持以windows服务方式运行web服务器(只在windows系统,不是必须)<li>复制文件core里的文件,还有customsetting.json,以及Program.cs<li>加入一个测试类Testapi.cs,添加几个处理请求的方法.具体可以参考MyWebApiCore项目代码.</ul><h5>模板</h5><p>上面的项目建好后,可以导出为项目模板.以后添加新项目选择模板即可.</div><div class="tabs-panel pd-lr-20"><h3>部署</h3><ul class="list num"><li>可直接使用,由于自带kestrel服务器,所以能独立运行.不用部署到其它web服务器环境内<li>直接使用时,kestrel服务器监听来自外面的请求.但一般不会这样,因为kestrel服务器运行时,会打开一个命令行黑窗口.如果服务死掉了或者被人关掉了,需要重新打开.<li>部署到IIS,Apache,nginx这些服务后面.托管asp.net core应用,可以自动重启,没有命令行黑窗口.<li>在windows平台,也可以托管在windows服务下,asp.net core程序支持以windows服务方式托管运行.只需要做很少的修改,这是种成本较低的部署方式.</ul><h5>IIS托管代理</h5><p>由IIS做监听,请求转发到kestrel.<p>1. IIS托管捆绑包,这个程序为IIS添加功能,使asp.net core程序可以托管.在下面这个页面下载:<p>找到 "当前 .NET Core 托管捆绑包安装程序" <a href="https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/hosting-bundle?view=aspnetcore-5.0">https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/hosting-bundle?view=aspnetcore-5.0</a><p>安装后IIS的模块里会多出两个模块: AspNetCoreModule 和 AspNetCoreModuleV2<p>2. 发布程序时,选择发布到文件,选择 "独立" 部署模式,运行时选择 "WIN-64".<p>3. 在IIS里新建立网站,程序池选择"无托管".物理目录里放入发布的项目.<p>4. web.config文件,发布项目时(win平台)会生成这个文件.把它复制到网站下.配置如下:<p>web.config文档: <a href="https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-5.0">https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-5.0</a><pre class=bg-gray-lt>

    &lt;?xml version="1.0" encoding="utf-8"?>
    &lt;configuration>
      &lt;location path="." inheritInChildApplications="false">
        &lt;system.webServer>
          &lt;handlers>
            &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModuleV2" resourceType="Unspecified" />
          &lt;/handlers>

          // 进程名字是自己项目的
          &lt;aspNetCore processPath="<strong>.\项目名字.exe</strong>"
                      stdoutLogEnabled="false"
                      stdoutLogFile=".\logs\stdout"

                      // 要使用进程外托管.
                      hostingModel=<strong>"outofprocess"</strong>/>
        &lt;/system.webServer>
      &lt;/location>
    &lt;/configuration>

</pre><br><h5>以windows服务方式托管运行</h5><ul class="list num"><li>添加引用 Microsoft.AspNetCore.Hosting.WindowsServices<li>将启动语句由.Run()修改为.RunAsService()<li>使用sc命令建立一个windows服务:(下面MyWebApiServer是服务名字,binPath是程序路径,注意=后面有空格,另外加一个参数s,启动据此判断是从控制台启动还是服务启动.DisplayName是服务显示名字)<li>sc create MyWebApiServer binPath= "dotnet D:\MyWebApi\bin\Debug\netcoreapp2.1/MyWebApi.dll s" DisplayName= MyWebApiServerAspNetCore<li>如果建立成功了,那么打开services.msc 就能找到这个服务,然后点击启动服务.成功后,可测试调用API.<li>也能用sc命令启动服务: sc start MyWebApiServer</ul><p>注意事项:<ul class="list num"><li>安装服务时,如果直接将编译目录下的MyWebApi.dll当做服务程序路径,那么当编译项目时,会报错占用文件.这时在编译前需要先停止服务.<li>执行停止服务命令 sc stop MyWebApiServer</ul><p>以windows服务方式运行,参考文章 <a href=https://www.cnblogs.com/guogangj/p/9198031.html>https://www.cnblogs.com/guogangj/p/9198031.html</a></div><div class="tabs-panel pd-lr-20"><h3>静态文件</h3><p>相关nuget包: Microsoft.AspNetCore.StaticFiles<p>静态文件参考文档: <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-2.2#serve-static-files">https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-2.2#serve-static-files</a><p>静态文件的默认目录是 <strong>wwwroot</strong> ,位于目录 {content root}/wwwroot<p>调用无参数 UseStaticFiles() 方法重载将启用静态文件功能, 提供wwwroot 目录中的文件.<h5>自定义静态文件目录</h5><p>可以配置多个目录,调用 UseStaticFiles(cfg1).cfg1参数里指定了一个物理目录和对应的虚拟目录.<p>这个功能可以在kestrel服务器建立虚拟目录.例如物理目录 "d:/root/img" 虚拟目录 "/cdn/img"<h5>默认文档</h5><p>指定一个文件在网址打开时显示.例如 index.html<p>中间件是 UseDefaultFiles(cfg) 通过 cfg配置 可以指定多个默认文档.<h5>中间件顺序</h5><p>默认文档要在静态文件之前调用.而项目自定义的路由中间件要在最后调用,否者静态文件会找不到.<p>具体代码见项目Program.cs/静态文件配置项</div><div class="tabs-panel pd-lr-20"><h3>url示例</h3><p>见项目测试页,运行项目后打开服务器地址.<p>1. 这个url调用的是demo类的gethtml方法,返回html<p>/demo/gethtml<p>2. 这个url调用的是demo1的index方法,api是demo1类的命名空间.这个功能可以将API分类(文件夹)<p>/api/demo1/index</div><div class="tabs-panel pd-lr-20"><h3>配置</h3><p>感觉配置比较复杂了,不熟悉依赖注入不容易看明白.<p>理解的配置逻辑<p>1. 整个程序由一个主机承载 IHost,可以为这个主机添加服务(功能),这需要配置,配置是一个方法当做参数,传入主机对象的加载配置方法里<pre class=bg-gray-lt>

      void servicesConfigure(IServiceCollection services)

</pre><br><p>配置方法传入到主机进行依赖注入的地方是<pre class=bg-gray-lt>

      hostBuild.ConfigureServices(servicesConfigure);

</pre><br><p>2. 往主机里添加一个web服务器,这也是一个主机,需要加入服务,配置方法<pre class=bg-gray-lt>

      static void webHostBuild(IWebHostBuilder webBuilder)

</pre><br><p>配置传入web主机<pre class=bg-gray-lt>

      hostBuild.ConfigureWebHostDefaults(webHostBuild);

</pre><br><p>webHostBuild里面是具体配置,服务器监听地址,其它功能等.</div><div class="tabs-panel pd-lr-20"><h3>差别</h3><p>asp.net core与经典的asp.net的差别比较大了,功能上感觉更先进,处理程序设计上也改进很大<ul class="list num"><li>自带服务器kestrel,可以独立部署.除了windows,可部署Linux,真正跨平台.<li>中间件相当于管道事件,可以自由定义,而不用限制在asp.net的十几个事件点上.<li>系统自带了丰富的中间件,像跨域之类的.只需要配置一下就跨域了.mvc webapi这些框架也都有,习惯差不多.不过前后端分离的话,这些基本没用了.</ul></div></div></div><hr class=line><br><br><br><br><br><br><br><script src=/asset/js/article.js></script><script src=/mirrorui/mirrorui.js></script><script>window.ns.tabs("mytabs1")</script></div></div><script src=/asset/js/mainmenu.js></script>