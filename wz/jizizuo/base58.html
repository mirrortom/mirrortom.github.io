<!DOCTYPE html><html lang=en><head><meta charset=utf-8 /><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1" /><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no" /><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png /><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png /><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png /><link rel=manifest href=/site.webmanifest /><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5 /><meta name=msapplication-TileColor content=#da532c /><meta name=theme-color content=#ffffff /><title>base58研究 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet /><link href=/asset/css/blog.css rel=stylesheet /></head><body><div class=layout><div class=layout-part1></div><div class=layout-part2><div class=wz-page><p>以前知道有个base64编码,也没研究过是怎么回事,只知道文件可以转为这种编码的形式,它是一个字符串,于是二进制的文件可以变成字符串了</p><p>后来接触到区块链,了解到base58编码,在查看了资料后,大概理解是什么回事了.</p><h3>回顾进制</h3><p>2进制,8进制,10进制,16进制,58进制,64进制.在学校了解过的进制就是2,8,10,16,当时明白了位权概念和转换方法,但不觉得有什么用途.</p><p>基础数位,十进制是0~9[0,1,2,3,4,5,6,7,8,9], 8进制是0~7 2进制是0,1 那么有多少基础数位就是多少进制,这样想也许是不对的,但为了能理解先就这样吧.</p><p>那么十六进制,就是16个基础数位.[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F].在校刚接触时脑筋转不过来,怎么能abcd也进来了呢,这明明不是数啊.换一种公式想法就是</p><p>m进制的基础数位有m个,最小数位值为0,最大数位值为m-1.例如十进制,最小是0,最大为9(10-1).同理十六进制,最小为0,最大为15(16-1).可是表里没15,有个F</p><p>那个F就是15.为什么要用F代替15呢?基础数位含意就是,这种进制的数都是由这些基础数组成的,不能再分,例如任意十进制数都是由0~9基础数的1个或多个组成.十六进制</p><p>的15如果写成15那是两个数了,由1和5组成,不是不可再分的基础数位,所以肯定要用单个字符来表示15.那为什么是F表示呢,其实只要用单个字符且不与其它基础数重复</p><p>都行.既然已经约定好,那就只能沿用,否则不兼容.</p><h3>定义进制</h3><p>进制的理论了解后,可以自由定义m进制.找到m个不相同的基础数位就行.例如26进制,可以找[A~Z]26个字母做基础数位.100进制,找齐100个不重复的字符就行.</p><p>m个基础数位找好后,再写m进制与十进制之间的转换算法.那就能用这个进制表示数了.算法就是每个基础数位值乘m的位权次方最后相加得到十进制.先回顾十进制</p><p>十进制数512, 5*10^2 + 1*10^1 + 2*10^0 = 500 + 10 +2 = 512 末位的2位权是0,向前位权依次加1,最高位的5位权是2.</p><p>十六进制数A1F, A*16^2 + 1*16*1 + F*16^0 = 2591 这个公式其实是 10*16^2 + 1*16*1 + 15*16^0 其中 A=10,F=15 为何如此?先看下基础数位,十六进制的基础</p><p>数位是[0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]注意这个顺序(第1位从0算起),A是第10个,F是第15个,那么A=10,F=15是这个原因吗?本质上讲,是一种约定,m进制有m个基</p><p>础数位,最小值是0,然后是1,...最后,最大值是m-1.十六进制的[0~F],是约定了0~15个基础数位的表示形式,这种约定通过所在列表中的位置体现出来,A在列表中是第10个</p><p>所以A表示10.这可以用一个表格来清楚的约定对应关系.字符表示成哪种形式没有关系,只要约定好哪个字符对应哪个值就行.越方便直观越好.看起来,形式2比形式1不好.</p><div class=grids id=box1></div><div class=grids id=box2></div><div class=grids id=box3></div><h3>58进制</h3><p>想通了表示形式与值的关系,那么,58进制也不难理解了.base64是64进制,所以有64个基础字符</p><p>base64基础字符:[A..Za..z0..9+/] 一共有 26 + 26 + 10 + 2 = 64 个字符</p><p>base58基础字符:[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz] 一共有 24 + 25 + 9 = 58 个字符,在base64上去掉了4个字符</p><p>[0 O I l]分别是数字0,大写字母O,I,小写字母l.另外"+/"这两个也不用</p><h3>58进制数转十进制数</h3><p>58进制数ChJ转为10进制数是39341,算法是 C*58^2 + h*58^1 + J*58^0 = 11*58^2 + 40*58^1 + 17*58^0 = 39341</p><p>将十进制数94022转为58进制数是Ux5,算法如下</p><p>94022除58 商=1621 余=4 余数4就是其对应58进制数的末位,而4所在的58进制的基础数位形式是5.重复这个过程,再用1621/58 商=27 余=55,55为次位,对应x,</p><p>再用27/58商=0 余=27,即为最高位,对应U,合起来就是Ux5.当商为0时,余数就是最高位,重复过程停止.</p><h3>base58编码与二进制数据转换</h3><p>二进制数据是在程序中以字节表示,1个字节是8个二进制位,而8个二进制位能表示的正数范围,转为十进制值,范围是[0-255].也就是说一个字节能表示成十进制的</p><p>[0~255]之中的1个数,那么将这个数转为58进制的,就得到了这个字节的58进制表示形式,是一个字符串.反过来,将这个58字符串转为十进制值,就得到一个字节,</p><p>那么就实现字节与58字符串互相转换了.假如字节值为0,那么对应58值是1,字节值为255时,对应值是5Q.</p><h3>字节与58编码互相转换</h3><p>既然字节是个0~255的数字,可以与其它进制互转.任何数据在计算机中都是二进制的,那么可将任何数据转成以58个字符表示的文本形式.这里会碰到一个问题,如何将</p><p>58文本再转为字节?base64的算法是,对于一个给定的字节序列,每三个字节一组,得到24个bit,然后再分成4部分,每部分6个bit,然后将每个部分前面补上两个0,补出</p><p>4个字节,例如"00000000"或者"00111111",由于前面两位是0,所以补出来的字节值范围是[0~63],这正好对应base64的64个基础字符,所以这样每一个字节都能使用一个</p><p>base64符号表示.再从base64字符转回来时,每4个字符再换回原来的3个字节.有个细节是,如果原来的字节序列总数,如果不是3的整数倍时,会在最后剩余的1~2个字节补"="</p><p>所以base64后面有时会有"="号.</p><p>那么base58如果使用这个办法则不好,因为[0~63]对应64个字符,而base58只有58个,所以势必有6个字节[58,59,60,61,62,63],会由两位的58字符表示,这样一来,就不像</p><p>base64那样,每个字符能表示一个字节了.此时必须使用其它办法.</p><h3>一种转换办法</h3><p>对于给定的字节序列byteArray,每4个字节为一组,形成一个4字节的正整数.范围是[0~4294967295],对应的58进制范围是[1~7YXq9G],对应的二进制是:</p><p>[00000000000000000000000000000000~11111111111111111111111111111111]</p><p>字节为最大值时对应的58进制值是7YXq9G,是一个6位数.那么每4个字节最多需要6位58进制字符来表示</p><p>所以,每4个字节兑换6个58进制字符,如果不足的话,在高位补1(1对应58进制的0).</p><p>字节序列可能不是4的整数倍,所以最后会剩余1~3个字节.将这些字节每个转为两位58进制字符.此时会有两种情况,当剩余1~2字节时,会兑换成2~4个字符,当剩余3个字节时</p><p>会兑换成6个字符,这与4字节兑换6个字符的规则不符.再解码时会造成错误,所以如果是剩余3字节,最后加个"="号标识.这个学习base64的做法.</p><p>58字符串解码时,按照上述编码逻辑,每6个字符串兑换4个字节,先检查末尾有没有"="号.有则减去最后7个字符再整除,否则直接整除,最后剩余的字符串每两个兑换1个字节</p><p>编程实现过程中需要用到移位操作,C#的移位操作符在进行移位时,如果是有符号数,那么会有符号位问题,所以要转为uint这种无符号正整数来操作.</p><h3>总结</h3><p>做这个程序需要的基础知识有进制,补码,字节.在学校时理论课基本都有,不过只学不用,很快就忘了.关键处是字节与字符的对应关系,其实可以有很多种算法,只要能互转回来</p><p>都可以.可以考虑一些其它因素而采用较优的算法,例如算法复杂度,转换后字符串比原字节增大倍数等.</p></div><hr class=line /><script src=/asset/js/article.js></script><script>(()=>{let n=n=>{let t="";for(var i in n)t+=`<span class="grid">${n[i]}</span>`;return t};document.querySelector("#box1").innerHTML=n(["值",0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);document.querySelector("#box2").innerHTML=n(["形式1",0,1,2,3,4,5,6,7,8,9,"A","B","C","D","E","F"]);document.querySelector("#box3").innerHTML=n(["形式2","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P"])})()</script></div></div><script src=/asset/js/mainmenu.js></script></body></html>