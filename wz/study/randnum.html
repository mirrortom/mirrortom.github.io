<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>随机数学习 | Mirror Space</title><link href=/asset/css/blogArticle.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class="layout-part2 layout-article"><div class=wz-page><div class=txt-center><h1>随机数学习</h1><span class=txt-gray-5>作者: </span><span>mirror</span> <span class="mg-l-10 txt-gray-5">日期: </span><span>2018/8/3</span></div><hr class="bd-none bd-t-1 bd-t-gray-4 mg-t-10"><div id=page_content><h4>随机数</h4><p>随机数理论学习,随机数是如何创造的?<p>例如这组数 1,35,5664,3,5,6,78,234,675,47<p>它们看起来是随意的,里面可能会重复.它们是一个随机数序列.这个序列的顺序是固定的,第1位是1,第2位是35.这个序列是手工写的.<p>显然,计算机要使用一种算法来自动生成这个序列,而不是用人工来写.<h4>中方方法-随机数生成算法</h4><p>冯诺依曼提出的中方方法 : 将一个n位数平方,结果表示为2n位数(不够左边补0),取其中间的n位数.这个数就是得到的随机数.<p>例如:1234这个数(n=4),平方后是1522756,表示为2n位数是 01522756,中间n位数是 5227 这个数就是由1234得到的随机数<p>将上例得到的5227继续采用中方方法会得到下一个随机数,一直这样下去,就产生了很多随机数.于是,通过算法得到了随机数序列.<p class=txt-danger-5>这个方法的不足在于,计算出的下一个随机数,可能是0.这样以后的结果就都是0了.明显这是错误的.<h4>中方方法-计算</h4><div class=grids><label class="input-label grid-12 text-left">输入一个数据以计算其中方方法随机数</label><input class="input-text grid-3" type=text id=zfinput> <span class=btn id=zfBtn>计算</span></div><div id=showmsgbox></div><h4>线性同余法</h4><p>同余法是说,如果两个整数a，b用m除，所得的余数相同，则称a，b对模m同余<h4>使用此法计算随机数的 公式</h4><p>X[n+1] = (A * X[n] + C) mod M<p><b>公式说明 : </b> 用一个初始值Xn,乘以正整数A,加上正整数C.然后对正整数M取模.得到的值就是下一个随机数.<h4>近似随机数</h4><p>这两种算法生成的随机数,都有一个特点就是生成的随机序列是固定的,不管什么时候生成,随机数都是按固定的顺序出现.因为算法是固定的,种子值是固定的.算法无法生成真正的随机数.<p>中方方法有明显缺点,所以使用线性同余法.为了让随机数近似随机,关键是选定A,C,M的值.<p>研究线性同余法公式发现,随机数序列的产生有周期性.假设 2,5,6,1,5,2,5,6,1,5 这个随机序列,第6位开始,其实是一种重复.由于算法固定,这种重复一定会发生.至于在第几位发生,取决于ACM的选择.<p>经过前人的理论研究,用线性同余法产生随机数时.为了得到近似随机数(是为了得到最大周期).ACM的值如下选择.<ul class=list><li>M尽可能的大(这样周期就大) 可以取系统位数,例如 32位系统,取2^32<li>A与M互质<li>C选0或者1 如果不为0,那么C与M互质.如果为0,那么M要选质数.<li>A,C要比M小,ACM都是正整数</ul><p>重复周期越长,随机性越好.如果需要每次都产生不一样的序列,那么每次要传入不同的种子.这样,近似随机数就实现了.<h4>ACM选择示例:最小随机数生成器</h4><p>A = 16807 C = 0 M = 2147483647<p>X[n+1] = 16807 * X[n] % 2147483647<p>输入种子和个数生成随机数序列(种子不为0,个数最多1K个)<div class=flex><input id=random_seed class="input-text grid-2" type=text maxlength=1000 placeholder=种子不能为0><input id=random_count class="input-text grid-2" type=text maxlength=3 placeholder=最多1000个><a class="btn info" id=createnumBtn>生成</a></div><div id=random_numsbox></div><script>(()=>{function i(){let n=document.getElementById("zfinput").value;if(n.length!=0&&!isNaN(parseInt(n))){let t=Math.pow(n,2),r="";for(var u=0;u<2*n.length-t.toString().length;u++)r+="0";let i=r+t,f=i.substr((i.length-n.length)/2,n.length),e=`<p class="paragraph f16">种子数 : <strong>${n}</strong> | 平方 : <strong>${t}</strong> | 2n长度表示 : <strong>${i}</strong> | 中间n位 : <strong>${f}</strong></p>`;document.getElementById("showmsgbox").innerHTML=e}}function r(){let r=document.getElementById("random_seed").value,u=document.getElementById("random_count").value,n=r,t="";for(var i=0;i<u;i++)n=n*16807%2147483647,console.log(n),t+='<span class="label info mg-5">'+n+"<\/span>";document.getElementById("random_numsbox").innerHTML=t}let n=document.getElementById("zfBtn");n.onclick=()=>{i()};let t=document.getElementById("createnumBtn");t.onclick=()=>{r()}})(window)</script></div></div><div class=nav-page-inside><h6 class=txt-center>本文内容</h6><div class="flex flex-col" id=navOfInPage></div></div></div><div class="bd-t-1 bd-t-gray-3 txt-center mg-b-10">End Line</div></div><script src=/asset/js/mainmenu.js></script><script src=/asset/js/navinpage.js></script>