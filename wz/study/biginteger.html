<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>文章 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class=layout-part2><div class=wz-page><h3>字长</h3><p>计算机能表示的数值大小有限制,受限于字长.例如8位机能表示的整数范围[-128~127],二进制是[10000000~01111111]<p>64位计算机能表示的无符号整数是2^64-1.总是有个范围,而如果要表示超过个范围的数,则需要另想办法.<h3>BigInteger类</h3><p>C#的BigInteger类用于表示超过字长范围的数. 理论上长度无限,在计算机中受限于内存大小.<p>文档: <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.biginteger?redirectedfrom=MSDN&view=netframework-4.8" target=_blank>https://docs.microsoft.com/zh-cn/dotnet/api/system.numerics.biginteger?redirectedfrom=MSDN&view=netframework-4.8</a><p>该类提供了很多方法,除了表示大整数外,可以对其进行加减乘除取余移位等操作.这次研究它提供的构造方法,将一个字节序列转为大整数.<h3>示例byte[]转BigInteger</h3><p>定义10长度的字节序列 byte[] arr = byte[10] 将最后一位赋值1: byte[9] = 1<p>实例化成大整数 BigInteger a = new BigInteger(arr); 它的值是 4722366482869645213696 是个长度为22的大整数,那么是如何得来的.<p>根据测试,Biginteger将传入的数组从后往前分别做为大整数的二进制形式的高位到低位.arr字节序列转换为大整数后二进制如下:<p>00000001,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000 总共10个字节,而这个计算出来变成十进制就是<p>2^72 = 4722366482869645213696 注意,最高位表示符号位,如果是1则为负值,二进制是补码.而如果是0,则是正值.这是一个由10字节表示的大整数.<p>反过来,通过ToByteArray()这个实例方法,可以由大整数得到它的字节.<h3>正负</h3><p>由于字符最高位是符号位,所以数会有正负问题.在希望得到正整数的时候,使用这个构造函数 new BigInteger(bytes,true) 第二个参数true说明是无符号数<h3>字节高低位</h3><p>示例中得到的大整数的字节高低位与传入的字节数组索引高低位相反,最后一个索引的字节是大整数的二进制最高位.这个习惯感觉是倒着的,如果字节数组的0位<p>就是大整数二进制的最高位,那么感觉会习惯一些.new BigInteger(bytes,true,true) 第三个参数为true时,可以实现.<p>这个问题其实是 Little-endian：将低序字节存储在起始地址(低位编址) 和 Big-endian：将高序字节存储在起始地址(高位编址)<p>具体就没研究,显然,只要按同一个方案来,就没问题</div><hr class=line><script src=/asset/js/article.js></script></div></div><script src=/asset/js/mainmenu.js></script>