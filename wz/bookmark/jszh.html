<!DOCTYPE html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>计算之魂 | Mirror Space</title><link href=/asset/css/blogArticle.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class="layout-part2 layout-article"><div class=wz-page><div class=txt-center><h1>计算之魂</h1><span class=txt-gray-5>作者: </span><span>吴军</span> <span class="mg-l-10 txt-gray-5">日期: </span><span>出版2022年</span></div><hr class="bd-none bd-t-1 bd-t-gray-4 mg-t-10"><div id=page_content><p>片段记录<h2>引子 计算的本质--从机械到电子</h2><p>一个具有运算能力/可能还有一定存储能力的机器设备,受指令控制,包括但是不限于计算机/智能手机/平板电脑/电子个人助理/阅读器/程控交换机/智能传感器(含各种可穿戴式设备)/有处理器的医疗仪器/服务器/存储设备等.<p>相比算盘,帕斯卡机械计算机的优点在于使用者不需要训练.当然它也有不足之处:计算之前输入数据太慢,导致整个计算过程速度太慢.这个现象其实反映出计算机发展过程中一直存在的一个大问题,就是数据输入(和输出)的速度可能远远跟不上计算的速度.这一点是我们需要牢记的.<p>巴贝奇和阿达的想法非常好,即采用程序控制物理运动实现计算,这其实就是计算机的本质<p>楚泽通过自己的实践证明了使用布尔代数可以实现任何十进制的运算,并实现复杂的控制逻辑.香农则从理论上指出任何逻辑控制和计算都和开关电路等价,奠定了今天数字电路设计的基础,今天的计算机实际上是一种特殊的数字电路.<p>人工智能的计算机之所以显得很聪明,能做越来越多的事情,只是因为很多问题过去大家没有找到转变为数学问题的桥梁,现在找到了而已.<p>香农的电路设计思想可以被总结为"模块化"和"等价性".<p>在这个世界上,并非所有的问题都是数学问题,即便是数学问题,也并非都可以通过计算机来解决.图灵的超越时代之处在于,他在还没有电子计算机的时候,就划定了可计算问题的边界.<p>一台计算机应该包括计算/存储和控制三个部分.人们通常注意到的其实是前两个部分,忽视的是控制部分.计算机从本质上来讲是在不断地做机械运动,能够进行什么样的计算/完成什么样的任务,就看人们如何控制计算机了.<h2>第1章 毫厘干里之差--大O概念</h2><p>人其实本能地对大数没有什么概念,毕竟我们生活在一个小数的世界里.同样,我们对很快的速度也是没有概念的,因为我们生活在一个很慢的世界里.<p>所谓提高一台计算机软硬件的效率,就是将多余的计算全部挑出来省掉.<p>对于学习计算机科学的人来讲,排序算法是打开计算机科学之门的一把钥匙.<p>要理解它们,关键是要掌握两个计算机科学的精髓一递归和分治,而这两者与我们日常的经验略有不同,因此不少人跨不过直觉这道坎,理解计算机算法就非常费脑筋.<p>在找到时间复杂度为O(NlogN)的排序算法后,照说在数量级上不可能再有更好的排序算法了(这一点我们会在本章的附录里证明),但是毕竟相同数量级的算法仍可能有常数倍的差异.因此虽然在算法复杂度上寻找同数量级算法是一件没有意义的事情,但是如果在工程上能保证个算法的实际运行时间总是比其他算法少一些还是有人愿意研究的<p>首先,要尽可能地避免那些做了大量无用功的方法,比如选择排序和插入排序,一旦不小心采用了那样的方法,带来的危害有时是灾难性的;其次,接近理论最佳值的算法可能有很多种,除了单纯考量计算时间外,可能还有很多考量的维度,因此有时不存在一种算法就比另一种绝对好的情况,只是在设定的边界条件下,某些算法比其他的更适合罢了.<p>因此在衡量计算机算法的效率时,我们假定要处理的问题规都非常巨大,近乎无穷.然后,我们需要找到计算量和问题规模之间的函数关系.<h2>第2章 逆向思考--从递推到递归</h2><p>和人不同,计算机在一开始就被设计用来处理规模大得多的问题,因此计算机有条件采用与常人完全不同的方式来解决问题.如果一个人能够站在计算机的角度想问题,我认为他具有"计算思维",这就如同我们说某个人具有科学思维或者工程思维一样<p>但是,计算机本身不具有推理能力,因此需要人赋予它,这就要求程序的结构本身简单.递归算法的好处在于,它不需要总结所渭的普遍规律,只需要搞清楚如何拆解问题即可.递归算法对应的代码通常在逻辑上都非常简洁,因为我们只要定义最顶层的逻辑,而下面一层层的逻辑不过是自动复制顶层逻辑而已.<p>要想在计算机科学领域做到随心所欲,必须转换我们人类固有的思维方式.做到这一点,就有成为四级工程师的可能性了.<p>从事计算机软件开发的人,要想站得高看得远,就要对自己提出更高的要求.自己所经手的任何一个程序,必须要了解它内部各种函数和过程调用的关系,而那些调用都是在堆栈的帮助下实现的.因此,对堆栈的深刻理解可以帮助开发者从上往下俯视一个程序.<p>今天几乎所有的计算机程序都是由一个个功能模块(通常被称为函数或者过程)相互嵌套而成的,这些相互嵌套的模块彼此在相互调用时,就需要使用堆栈来记录调用的过程了.<p>一个可单独运行的完整程序会有一个主函数,一般是空壳,通过调用真正的功能模块完成其任务.在功能模块中,整个程序要完成的功能被分解为一个个封装好的独立模块,它们之间可以相互调用,最后实现整个程序的设计功能.<p>但是随着计算机的发展,程序变得越来越复杂,一个大程序有上百万行代码是很常见的事情,因此程序员不可能把所有的步骤顺序想清楚,而只能先把大框架想清楚,再层层递进解决细节问题.<h2>第3章 万物皆编码--抽象与表示</h2><p>大家在提出一种编码时,只考虑了自己周围的情形,不了解甚至不需要了解全局.此外,人在对不同的对象进行编码时,主要考虑是否好记,而计算机则是强调效率.<p>在计算机行业里,从业者有无经验常常体现在动手开干之前,能否站在计算机的角度审视一遍自己的想法.这是四级工程师和五级工程师的差异.<p>计算机初学者常常很困惑的一件事就是,为什么计算机总是先要绕一个弯,找到地址才能找到内容,因为计算机就是这么设计的,和我们人的思维方式不同.<p>在计算机的发展过程中,很多高级语言被发明出来,比如c/C++和Java.发明这些语言,就是为了弥补机器语言不够直观的缺陷.因此高级语言的本质是连接人的解题步骤编码和机器解题步骤编码之间的桥梁.<p>一个资深的工程师,需要能够站在大公司顶部全面考虑公司的研发.比如在做对比试验时,需要用尽可能少的资源同时完成多项任务,这又要用到计算思维了.在上述问题中,能灵活运用编码原理解决整个公司层面的问题的人,就有了成为三级工程师的潜力.<p>在计算机中,很多地方都可以用到增量编码.这从一个侧面反映出,有规律的渐变是我们这个世界的各种信息存在的普遍现象,突变其实比较少见.我在很多场合都在宣传保守主义的做事原则.保守主义不是不变,而是强调利用增量来改变世界,这样代价最低.在计算机领域,竞争力就体现在用最低的代价做更多的事情.<p>今天,大部分标准的编码算法都有开源代码可以直接使用,如果你只会使用代码库的代码,可能还没有达到五级工程师的水平,因为能够看懂代码是这一级工程师的基本要求.能够理解那些编码算法的原理,是四级工程师的要求.如果你想达到三级工程师的水平,就需要能根据情况修改那些标准的编码,在特定情况下将其性能提高一个数量级,或至少提高几倍.<p>任何一个合格的计算机工程师,都应该掌握稀疏矩阵的存储和使用方法,这是五级工程师的基本要求.有些工程师可能一辈子都不会遇到一个矩阵需要存在100台服务器的情况.能够实现一个大矩阵(比如需要成百上千台服务器进行存储和运算)是对四级或3.5级工程师的要求.<p>信息的编码和有效表示是计算机科学和工程的基础.虽然大部分人能够为现实世界里的一个对象找到某种计算机能够识别与处理的表示方法,但是未必能做到有效.在计算机中表示信息,最关键的是把握二分这个原则,因为计算机是和二进制相连的,而二进制可以表示任何信息.<h2>第4章 智能的本质--分类与组合</h2><p>很多智能问题都是模式分类的问题,计算机科学家的任务就是将现实生活中的这些问题变成分类问题.<p>"二分"这个概念,以及和它对应的二叉树,对于计算机科学的重要性,犹如质量和长度之于物理学/元素和反应之于化学的重要性,这一点是每一个计算机从业者都要牢记的.<p>在计算机进行数据处理最常用的软件--数据库系统中,通常用B+树,而不用二叉树或者N叉树存储信息.<p>此外,B*树对合并小节点和将大节点一分为二的机制做了调整,使得树中浪费的空间更少.著名的Oracle数据库就采用了B*树的存储结构.<p>通过卡特兰数,我们可以看到很多计算机科学中的问题都是等价的,其中一个问题得到了解决,一大类问题就都能迎刃而解.<p>很多智能问题其实是分类问题.确认一个类别或者集合的边界常常有两种方法,即采用二叉判断,或者通过枚举的方式给出集合中全部的元素.这两种方法也是组织信息的常用方法.<h2>第5章 工具与算法--图论及应用</h2><p>今天很多复杂的系统依然可以简化为这种只有节点和边的抽象的图.比如整个互联网,从物理结构上看,它是一个个服务器以及连接服务器的网络线构成的一张图,服务器是节点,网络线是边.从逻辑上看,每一个网页是节点,而彼此引用的超链接则是边.<p>就这样,图论经过上百年的发展,成为解决数学问题和计算机科学问题的重要工具.这个工具核心自然是图,那么图的本质是什么?它是对离散的/有限集合中各个元素之间关系的描述.<p>计算机行业的从业者想真正实现一个搜索引擎可使用的网络爬虫,需要达到三级工程师的水平,能够应付遞到的各种复杂的工程情况,比如上述的六个问题.<p>我们在前面讲到,对三级工程师的要求是能够把一件事情做到世界最好,对二级工程师的要求则是能做到世界上其他人做不到的事情,这些都需要从掌握动态规划这样的思想开始.<p>图是一个抽象的数学概念,但是现实中的很多目标都可以用图来描述.图的核心是点与线,点(节点)代表实体,而线代表点之间的关系.如果这种关系不是简单的有和无,而是有一个量化的度量,那么对应的图就是加权图.<h2>第6章 化繁为简--分治思想及应用</h2><p>如果说在计算机科学中第一重要的思想是递归,第二重要的恐怕就要算是分治(Divide and Conquer)算法了.对分治算法理解的水平和应用得得心应手的程度,是衡量一个人计算机科学素养的标尺.这一关不突破,就无法成为四级工程师.<p>要想成为一流的软件工程师,就需要有能力解决其他人无法解决的大问题,当大家都有同样的计算资源时,就看谁有能力把大问题分解了,分治算法是首选的工具.<p>计算机从业者对分治算法的理解通常有三个层次.第一个层次是理解它的大致原理,理解归并排序和快速排序算法,并且能套用教科书中的例子解决一些问题.第二个层次是理解它的本质,遇到参考书中没有答案的问题,或者前人没有遇到的新问题,能够用这个工具解决.到了这个层次的计算机从业者,在工业界就可以立足了.第三个层次是对分治算法的应用有所贡献,这就可以在学术界立足了,当然前提条件是吃透分治算法思想的精髓.<h2>第7章 权衡时空--理解存储</h2><p>如果只从硬盘上读一个数要多少时间呢?它的延时大约在10毫秒,这就是前面提到的数据访问的准备时间,它不随读/写数据的多少而变化.10毫秒和不到1纳秒的L1缓存读取时间相差了7～8个数量级,也就是1000万倍以上,即使和内存相比,也相差了5～6个数量级.由此可见硬盘不仅慢,而且只适合大批量顺序读/写数据,准备一次读取或者写入一大批数据.<p>从上面的分析可以看出,计算机的存储系统分了很多级,这在计算机的系统结构中被称为存储器层级.<p>虽然今天很多从业者不理解存储的细节也能编写程序,但是水平无法突破四级,打造一款好产品离不开对相应的技术以及计算机的存储特性的透彻理解.<h2>第8章 并行与串行--流水线和分布式计算</h2><p>于是他们发明了一种"大文件"(BigFile).这个大文件逻辑上将所有的网页放到了一个文件中,在物理上它以64MB的大小为单元,将逻辑上一个完整的大文件存成很多个小文件,每个文件称为一个"大块"(chunk).<p>一个计算机工程师在职业发展的过程中会遇到几个瓶颈,最难突破的瓶颈有两个:一是培养出对信息处理的"感觉",这种感觉就如同在开车时转弯和踩油门靠的是肌肉记忆,而非大脑记忆一样;二是懂得并且有能力站在系统的角度来考虑所有的应用问题.做到了这两点,基本上就接近了三级工程师的水平.<h2>第9章 状态与流程--等价性与因果关系</h2><p>不管是哪种称呼,如果完成任务的整个流程是一张图,它们就是图中的节点.因此,将一个看似很大/逻辑关系很复杂的流程抽象成一些过程,是软件工程师的基本能力.不仅程序设计如此,计算机硬件在工作时也是从一个状态进入下一个状态.<p>根据Google的软件开发规范,如果在代码中相同的代码哪怕只出现了两次,就一定要把它们提炼出来,写成一个单独的函数,在不同的地方调用.进而,如果有几个不同的过程或者函数功能相似,就必须归并为一个统一的函数.这不仅提高了代码质量,也让工程师的工作得以最大程度地被利用.<p>但是处理器内部并没有除法器,实际上除法是通过乘法/加减法和部分查表来完成的,一次除法相当于十几次的乘法和加减法.这也就是说,除法可以通过十几步操作大致等价为一系列处理器现有功能能够实现的操作.当然,了解了除法实现的这个细节,大家在写代码时要尽可能多用乘法,少用除法,从而提高运算速度.<p>将很多等价的情况合并为少数状态之后,很多时候状态之间是有因果关系的,也就是说从一个状态经过一些操作可以变成另一个状态.状态之间的这些联系就构成了一张图,此时很多问题就容易解决了,因为我们可以使用图论这个工具.<p>寻找因果关系链是debug工作最重要的技巧,所谓debug,其实就是根据出现的异常现象倒推原因,它是沿着因果关系链逆向推理的过程.这个逆向推理的终点,也就是造成异常的原因,就是bug.<h2>第10章 确定与随机--概率算法及应用</h2><p>而信息指纹能够确认真实性的原因,恰恰是随机性让不同的目标无法映射到同一个数字上.<p>在使用计算机解决问题时,通常会有一个理论上的最优算法,它们常常已经达到了极限,无法进一步改进.但是在应用中,我们依然有可能对某些特殊的情况进行进一步的优化,特别是在资源有限时,从而更有效地处理大部分情况.<h2>第11章 理论与实战--典型难题精解</h2><h3>随想</h3><p><i>计算之魂的含义是计算的道.虽然大道至简,但是一定博大精深,变换无穷.我觉得是没有可能性做到3级或以上的计算机工程师了,也许到4级都很困难.虽然如此,学习计算机的思维和处理问题的方式,是很有必要的,除了对写程序有直接帮助,将这些思想应用到生活中,可以从新的角度重新认识生活.</i><p><i>本质和关键的东西...计算的本质--机械运动,开关到电子,都是运动.可编程可控制的本质--布尔代数,能用开关电路实现与或非.二进制的--要处理信息的必须是0和1组成的,如果不是则要转化.模块化--软硬件设计分成功能模块,比如CPU计算模块/内存存储模块/IO输入输出模块.顶层规划--设计软硬件,从最终目的开始倒推细节.递归--复杂问题简化为同模式的简单问题,当问题简单到直接可解决时,原来的复杂问题就解决了.算法复杂度--大O概念,时间和空间的取舍.等价性--解决原问题的等价问题,就解决了原问题. 二叉树/图/二分/分治/栈/队列/堆/并行串行/状态机/随机数--解决问题的常用工具.</i><p><i>书里提到的题目没有一个能做出来的,偶尔做了1个,也是最简单的做法,而这些做法是没有实用性的,达不到工程师的等级水平.我觉得判断一个码农水平,可以从他解决的问题来看,如果解决的都是小规模问题,使用最简单的方法也没什么,但水平也会很低,只有解决大规模问题或者基于大规模问题思考,才有机会提高水平.</i></div></div><div class=nav-page-inside><h6 class=txt-center>本文内容</h6><div class="flex flex-col" id=navOfInPage></div></div></div><div class="bd-t-1 bd-t-gray-3 txt-center mg-b-10">End Line</div></div><script src=/asset/js/mainmenu.js></script><script src=/asset/js/navinpage.js></script>