<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>深入理解计算机系统 | 兰德尔.布莱恩特 大卫.哈利嗯 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class=layout-part2><div class=wz-page><p>书名: <strong>深入理解计算机系统 Computer Systems: A Programmer's Perspective</strong> 作者: <strong>Randal E.Bryant 兰德尔.布莱恩特/ David O'Hallaron 大卫.哈利嗯</strong><h4>片段记录</h4><h6>第1章 计算机系统漫游</h6><p>通过这个简单的示例我们了解到重要的一课,那就是系统花费了大量的时间把信息从一个地方挪到另一个地方.hello程序的机器指令最初是存放在磁盘上的.当程序加载时,它们被拷贝到主存.当处理器运行程序时,指令又从主存拷贝到处理器.相似地,数据串"hello,world\n"开始时在磁盘上,再被拷贝到主存,然后从主存上拷贝到显示设备.从一个程序员的角度来看,大量的拷贝减慢了程序的实际工作.因此,系统设计者的一个主要目标就是使这些拷贝操作尽可能的快.</p><canvas id=canvas1></canvas><p>存储器分层结构的主要思想是一个层次上的存储器作为下一层次上的存储器的高速缓存.因此,寄存器文件就是L1的高速缓存,而L1又是L2的高速缓存,L2是主存的高速缓存,主存是磁盘的高速缓存.在某些带分布式文件系统的网络系统中,本地磁盘就是其他系统中磁盘上被存储数据的高速缓存.<p>操作系统有两个基本功能:防止硬件被失控的应用程序滥用;在控制复杂而又通常广泛不同的低级硬件设备方面,为应用程序提供简单一致的方法.操作系统通过图1.11中显示的几个基本的抽象概念(进程|虚拟存储器和文件)实现这两个功能.如图1.11所示,文件是对I/O设备的抽象表示,虚拟存储器是对主存和磁盘I/O设备的抽象表示,进程则是对处理器|主存和I/O设备的抽象表示.<p>进程是操作系统对运行程序的一种抽象.在一个系统上可以同时运行多个程序,而每个进程都好像在独占地使用硬件.<h6>第2章 信息的表示和处理</h6><p>单独地来说,单个的位不是非常有用.然而,当我们把位组合在一起,再加上某种解释(interpretation),即给予不同的可能位模式以含意,我们就能够表示任何有限集合的元素.<p>每台计算机都有一个字长(word size),指明整数和指针数据的标称大小(nominal size).因为虚拟地址是以这样的字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小.也就是说,对于一个字长为n位的机器而言,虚拟地址的范围为0~2^n-l,程序最多访问2^n字节.<p>可以通过执行命令man ascii来得到一张ASCII字符码的表<p>计算机系统的一个基本概念就是从机器的角度来看,程序仅仅是字节序列<p>假定我们仅考虑有限长度的编码,那么十进制符号是不能准确地表达像1/3和5/7这样的数的.类似地,小数的二进制表示法只能表示那些能够被写成 x*2^y 的数.其它的值只能够被近似地表示.<p>IEEE浮点标准用 V = (-1)^s * M * 2^E 的形式表示一个数<ul class=list><li>符号(sign)s决定是负数(s=1)还是正数(s=0),而对于数值0的符号位解释作为特殊情况处理<li>有效数(significand)M是一个2进制数小数,它的范围在1~2-ε之间,或者在0~1-ε之间<li>指数(exponent)E是2的幂(可能是负数),它的作用是对浮点数加权</ul><h6>第3章 程序的机器级表示</h6><p>GAS中的每一个操作都有一个字符后缀,表明操作数的大小.例如,mov(传送数据)指令有3种形式:movb(传送字节)|movw(传送字)和movl(传送双字)<p>C提供了好几种循环结构,即while|for|和do-while.汇编中没有相应的指令存在.作为替代,将条件测试和跳转组合起来实现循环的效果.有趣的是,大多数汇编器根据一个循环的do-while形式来产生循环代码,即使在实际程序中,这种形式用的相对较少.其它的循环会首先转换位do-while形式,然后编译成机器代码.<p>switch(开关)语句提供了根据一个整数索引值进行多重分支(multiway branching)的能力.在处理具有多种可能结果的测试时,这种语句特别有用.它们不仅提高了C代码的可读性,而且通过使用一种称为跳转表(jump table)的数据结构使得实现更加高效.跳转表是一个数组,表项i是一个代码段的地址,这个代码段实现的是当开关索引值等于i时程序应该采取的动作.程序代码用开关索引值来执行一个跳转表内的数组引用,确定跳转指令的目标.和使用一组很长的if-else语句相比,使用跳转表的优点是执行开关语句的时间与开关情况(switch cases)的数量无关.<p>IA32程序用程序栈来支持过程调用.栈用来传递过程参数|存储返回信息|保存寄存器以供以后恢复之用,以及用于本地存储.为单个过程分配的那部分栈称为栈帧(stack frame).图3.17描绘了栈帧的通用结构.栈帧的最顶端是以两个指针定界的,寄存器%ebp作为帧指针,而寄存器%esp作为栈指针.当程序执行时,栈指针是可以移动的,因此大多数信息的访问都是相对于帧指针的.<p>call指令的效果是将返回地址入栈,并跳转到被调用过程的起始处.返回地址是紧跟在程序中call后面的那条指令的地址,这样当调用过程返回时,执行会从此继续.<p>在这些例子中,leal指令用来产生地址,而movl用来引用存储器(除了在第一种情况中,那里它是拷贝一个地址).最后一个例子表明我们可以计算同一个数据结构中的两个指针之差,结果值是除以数据类型大小后的值.<p>C的struct声明创建一个数据类型,将可能不同类型的对象聚合到一个对象中.结构的各个组成部分是用名字来引用的.结构的实现类似于数组的实现,因为结构的所有组成部分都存放在存储器中连续的区域内,而指向结构的指针就是结构第一个字节的地址.编译器保存关于每个结构类型的信息,指示每个域的字节偏移,它以这些偏移作为存储器引用指令中的位移,从而产生对结构元素的引用<p>联合提供了一种方式,能够规避C的类型系统,允许以多种类型来引用一个对象.联合声明的语法与结构的语法一样,只不过语义相差比较大.它们不是用不同的域来引用不同的存储器块,而是引的同一存储器块.<p>指针是C语言的一个重要特色.它提供一种统一方式,能够远程访问数据结构.<h6>第4章 处理器体系结构</h6><p>现代微处理器可以称得上是人类创造出的最复杂系统之一.一块手指甲大小的硅片上,可以容纳一个完整的高性能处理器,大的高速缓存,以及用来连接外部设备的逻辑电路<p>一个处理器支持的指令和指令的字节级编码称为它的ISA(Instruction Set Architecture,指令集体系结构)<p>硬件设计人员必须非常谨慎小心.一旦芯片被制造出来,就几乎不可能改正任何错误了.一开始就使设计正确是非常重要的.<h6>第5章 优化程序性能</h6><p>对许多程序都有用的度量标准是每元素的周期数(cycles pre element, CPE).这种度量标准帮助我们在更详细的级别上理解迭代程序的循环性能.<p>到目前为止,我们运用的优化都不依赖于目标机器的任何特性.这些优化只是简单地降低了过程开销和调用.<p>消除不必要的存储器引用.引入临时变量来保存中间结果.只有在最后的值计算出来时,才将结果存放到数组或全局变量中<p>因此,即使我们大幅度改进了系统的一个主要部分,我们的净加速还是很小.这就是Amdahl定律的主要观点--想要大幅度提高整个系统的速度,必须提高整个系统很大一部分的速度.<h6>第6章 存储器层次结构</h6><h6>第12章 网络编程</h6><p>客户端-服务器模型中的基本操作是事务(transaction)<p>客户端-服务器事务不是数据库事务,而且也没有数据库事务的特性,例如原子性.在我们的上下文中,事务仅仅是客户端和服务器之间执行的一系列步骤.<p>套接字(socket)是连接的端点(end-point).每个套接字都有相应的套接字地址,是由一个因特网地址和一个16位的整数端口组成的,用"地址:端口"来表示.当客户端发起一个连接请求时,客户端套接字地址中的端口是由内核自动分配的,称为临时端口(ephemeral port).然而,服务器套接字地址中的端口通常是某个知名的端口,是和服务对应的.<h5>随想</h5><p>2进制与16进制转换,每一个16进制数转换成4位2进制.例如 0x173a4c ,6位16进制数,可以选一个顺序,从右到左,每个数变成4位2进制.最右边开始: c=1100, 4=0100..最后得到结果.转换规律1111=f,而f是15.也就是说记住2和16进制对应的10进制数就可以了.反过来也是这样,每4个2进制用一个16进制,从右往左,如果左边不够4个,在左边补0.<p>第4章完全看不懂!!!</div><script src=/cavlib/cavlib.js></script><script>(()=>{function n(){let e=cavlib("canvas1").style(),n=e.ctx,u=480,f=360;n.canvas.width=u;n.canvas.height=f;n.font="16px serial";t(n,u,f);i(n,u,f);r(n,e,u,f)}function t(n,t,i){var u;n.save();n.moveTo(t/2,0);n.lineTo((t-i)/2,i);n.lineTo((t+i)/2,i);n.closePath();n.clip();n.beginPath();n.moveTo(t/2,4);n.lineTo((t-i)/2+2,i-4);n.lineTo((t+i)/2-2,i-4);n.closePath();n.stroke();n.beginPath();let r=(i-8)/6;for(u=0;u<5;u++){let i=(u+1)*r+4;n.moveTo(0,i);n.lineTo(t,i)}n.stroke();n.restore();let f=["寄存器","芯片上的L1高速缓存(SRAM)","芯片外的L2高速缓存(SRAM)","主存储器(DRAM)","本地二级存储(本地磁盘)","远程二级存储(分布式文件系统,Web服务器)"],e=t/2;for(n.save(),n.textAlign="center",n.beginPath(),n.fillText(f[0],e,r),n.beginPath(),n.fillText(f[1].substr(0,6),e,2*r-(r-16)/2),n.fillText(f[1].substr(6),e,2*r),n.beginPath(),n.fillText(f[2].substr(0,6),e,3*r-(r-16)/2),n.fillText(f[2].substr(6),e,3*r),u=3;u<f.length;u++){n.beginPath();let t=(u+1)*r-(r-16)/2;n.fillText(f[u],e,t)}n.restore()}function i(n,t,i){let u=(i-8)/6,f=u/2;for(var r=0;r<6;r++){n.beginPath();let i=(r+1)*u-(u-16)/2;n.fillText("L"+r+":",t/2+(r+1)*f,i)}}function r(n,t,i,r){var f;let e=(r-8)/6,u=16;t.lineArrow([u,e*2.5,u,u]);let o=["更小","更快","(每字节)","更贵的","存储设备"];for(f=0;f<o.length;f++)n.beginPath(),n.fillText(o[f],u*1.6,(f+3)*u);t.lineArrow([u,e*3.5,u,r-2*u]);let s=["更大","更慢","(每字节)","更便宜的","存储设备"];for(f=0;f<s.length;f++)n.beginPath(),n.fillText(s[f],u*1.6,e*3.5+(f+2)*u)}n()})(window)</script></div></div><script src=/asset/js/mainmenu.js></script>