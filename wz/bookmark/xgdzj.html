<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>小工到专家 | 安德鲁·亨特 大卫·托马斯 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class="layout-part2 layout-doc"><div id=page_content><div class=wz-page><p1>书名: <strong>实效程序员-小工到专家 The Pragmatic Programmer</strong> 作者: <strong>安德鲁·亨特 大卫·托马斯 Andrew Hunt David Thomas</strong></p1><h4>片段记录</h4><h6>第1章 注重实效的哲学 A Pragmatic Philosophy</h6><p>因为负责,注重实效的程序员不会坐视他们的项目土崩瓦解<p>责任是你主动担负的东西.你承诺确保某件事情正确完成,但你不一定能直接控制事情的每一个方面,除了尽你所能以外,你必须分析风险是否超出了你的控制.对于不可能做到的事情或是风险太大的事情,你有权不去为之负责|你必须基于你自己的道德准则和判断来做出决定.<p>尽管软件发几乎不受任何物理定律的约束,熵(entropy)对我们的影响却很大熵是一个来自物理学的概念,指的是个系统中的"无序"的总量,遗憾的是,热力学定律保证了宇宙中的熵倾向于最大化,当软件中的熵无序增长时,程序员们称之为"软件腐烂"(software rot)<p>每年至少学习一种新语言.不同语言以不同方式解决相同的问题.通过学习若干不同的方法,可以帮助你拓宽你的思维,并避免墨守成规<p>只有当你是在传达信息时,你才是在交流.为此,你需了解你的听众的需要|兴趣|能力.我们都曾出席过这样的会议:一个做开发的滑稽人物在发表长篇独白,讲述某种神秘技术的各种优点,把市场部副总裁弄得目光呆滞.这不是交流,而只是空谈.让人厌烦的(annoying)空谈<h6>第2章 注重实效的途径 A Pragmatic Approach</h6><p>系统中的每一项知识都必须具有单一/无歧义/权威的表示. DRY 原则<p>DRY法则告诉我们,要把低级的知识放在代码中,它属于那里.把注释保留给其他的高级说明.否则,我们就是在重复知识,而每一次改变都意味着既要改变代码,也要改变注释,注释不可避免地变得过时,而不可信任的注释比完全没有注释更糟<p>我们想要设计自足(self-contained)的组件:独立具有单一/良好定义的目的(Yourdon和Constantine为内聚cohesion.如果组件是相厅隔离的,你就知道你能够改变其中之一,而不用担心其余组件.只要你不改变组件的外部接口,你就可以放心:你不会造成波及整个系统的问题<table border=1><tr><td colspan=3>用户界面<tr><td>数据库访问<td>报告引擎<td>商业逻辑<tr><td colspan=3>应用框架<tr><td colspan=3>C标准库<tr><td colspan=3>操作系统</table><p>语言的界限就是一个人世界的界限 --维特根斯坦<h6>第3章 基本工具 The Basic Tools</h6><p>许多新程序员都会犯下错误,采用单一的强力工具,比如特定的集成开发环境(IDE).而且再也不离开其舒适的界面.这实在是个错误.我们乐于超越IDE所施加的各种限制.要做到这一点,惟一的途径是保持基本工具集的"锋利"与就绪<p>作为注重实效的程序员,我们的基本材料不是木头,不是铁,而是知识.我们搜集需求,将其变为知识,随后又在我们的设计|实现|测试|以及文档中表达这些知识而且我们相信.持久地存储知识的最佳格式是纯文本.通过纯文本,我们给予了自己既能以手工方式|也能以程序方式操纵知识的能力--实际上可以随意使用每一样工具<p>纯文本并非意味着文本是无结构的;XML|SGML和HTML都是有良好定义的结构的纯文本的好例子.通过纯文本,你可以做你通过某种二进制格式所能做的每件事情.其中包括版本管理.<p>提供"锋利"的小工具|其中每一样都意在把一件事情做好--Unix因围绕这样的哲学进行没计而著称.这一哲学通过使用公共的底层格式得以实行:面向行的纯文本文件用于系统管理(用户及密码|网络配置,等等)的数据库全都作为纯文本文件保存<p>尽管本节的许多例子给出的是生成程序源码的代码生成器,事情并不是非如此不可,你可以用代码生成器生成几乎任何输出:HTML|XML|纯文本--可能成为你的项目中别处输入的任何文本<h6>第4章 注重实效的偏执 Pragmatic Paranoia</h6><p>一定不要把固定的需求|不可违反的法则与那些仅仅是政策(policiy)的东西混为一淡,后者可能会随着新的管理制度的出台而改变.这就是我们为什么要使用术语"语义不变项"的原因--它必须是事物的确切含义的中心,向不受反复无常的政策的支配<h6>第5章 弯曲或折断 Bend,or Break</h6><p>创建灵活代码的一个关键概念是数据模型(model)与该模型的视图(view即表现)<p>元数据到底是什么?严格地说,元数据是关于数据的数据.最为常见的例子可能是数据库schema或数据词典.schema含有按照名你.存储长度及其他属性|对字段(列)进行描述的数据.你应该能访问和操纵这些信息,就像对数据库中的任何其他数据一样<p>但程序应在何时读取该配置?许多程序只在启动时扫揣这样的配置,这让人遗憾.如果你需要改变配置,这会迫使你重新启动应用.更为灵活的方法是编写能在运行时重新加载其配置的程序.这一灵活性也有代价:它的实现更复杂<p>当然,你可以用更蛮力的方法获得相同的结果,但你到的将是更脆弱的系统当它出故障时,国王的所有人马也许都无法使你的序再工作起来<h6>第6章 当你编码时 While You Are Coding</h6><p>不主动思考他们的代码的开发者是在靠巧合编程--代码也许能工作,但却没有特别的理由说明它们为何能工作,在"靠巧合编程"中,我们提倡要更积极地参与编码过程<p>作为开发者,我们也工作在雷区里,每天都有成百的陷阱在等着抓住我们.记住士兵的故事,我们应该警惕,不要得出惜误的结论.我们应该避免靠巧合编程--依靠运气和偶然的成功--而要深思熟虑地编程<p>不要做历史的奴隶,不要让已有的代码支配将来的代码.如果不再适用,所有的代码都可被替换.即使是在一个程序中,也不要让你已经做完的事情约束你下一步要做的事情.--准备好进重构.这一决策可能会影响项目的进度.我们的假定是其影响将小于不进行改动造成的影响<p>O()表示法<table border=1><tr><td>O(1)<td>常量型(访问数组元素,简单语句)<tr><td>O(lg(n))<td>对数型(二分查找)<tr><td>O(n)<td>线性型(顺序查找)<tr><td>O(nlg(n))<td>比线性差,但不会差很多(快速排序,堆排序的平均运行时间)<tr><td>O(n^2)<td>平方律型(选择和插入排序)<tr><td>O(n^3)<td>立方型(2nXn矩阵相乘)<tr><td>O(C^n)<td>指数型(旅行商问题,集合划分)</table><p>O()表示法并只适用于时间,你可以用它表示算法使用的其他任何资源.例如,能为资源消耗建模|这常常很有用<p>可是,软件的工作方式与此并不怎么相似.与建筑相比,软件更像是园艺.<p>重写,重做和重新架构代码合起来,成为重构(refactoring)<p>无论代码具有下面的那些特征,你都应该考虑重构代码: 重复--你发现了对DRY原则的违反. 非正交的设计--你发现有些代码或设计可以变得更为正交. 过时的知识--事情变了,需求转移了,你对问题的了解加深了,代码需要跟上这些变化. 性能--为改善性能,你须要把功能从系统的一个区域移到另一个区域<p>软件IC是人们在讨论可复用性和基于组件的开发时喜欢使用的比喻,意思是软件组件应该就像集成电路芯片一样进行组合.这只在你使用的组件已知是可靠的时,才能行之有效<p>对于更大|更复杂的服务器代码|提供其操作的内部视图的一种漂亮技术是使用内建的Web服务器.任何人都可以让web浏览器指向应用的HTTP端口(通常使用的是非标准的端口号.比如8080),并看到内部状态|日志条目|甚至可能是某种凋试控制面板这听起来也许难以实现,其实并非如此,你可以找到用各种现代语编写|可自由获取|可嵌入的HTML Web服务器<p>没有人应该制作他们不完全理解的代码<h6>第7章 在项目开始之前 Before The Project</h6><p>制作需求文挡时的一大危险是太过具体.好的需求文档会保持抽象,在涉及需求的地方,最简单的|能够准确地反映商业需要的陈述是最好的.这并非意味着你可以含糊不清--你必须把底层的语义不变项当作需求进行捕捉|并把具体的或当前的工作实践当作政策记入文档,需求不是架构,需求不是设计,也不是用户界面,需求是需要<p>要创建并维护项目词汇表project glossary)--这是定义项目中使用的专用术语和词汇的地方.项目的所有参与者,从最终用户到持人员.都应该使用这个词汇表,以确保一致性.这就意味着,可以访问词汇表的人员范围应该很广泛--这是采用基于Web的文档的一个有效论据<p>其次,语言自身的表达能力存在着问题.所有的图示技术和形式方法都任然依赖于用自然语言表达要进行的操做.而自然语言实在不能胜任这项工作.看一看任何合约的措辞:为了进行精确的表达,律师不得不以最不自然的方式扭曲语言.<p>Some Things Are Better Done than Described 对有些事情"做"胜于"描述"<p>作为注重实效的程序员,你应该倾向于把需求搜集|设计|以及实现视为同一个过程--交付高质量的系统--的不同方面.不要信任这样的环境:搜集需求,编写规范|然后开始编码,所有这些步骤都是孤立进行的.相反,要设法采用无缝的方法:规范和实现不过是同一个过程--设法捕捉和编纂需求--的不同方面.每一步都应该直接流入下一步,没有人为制造的界限.你将会发现.健康的开发过程鼓励把来自实现与测试的意见反到规范中.<p>还有一些开发者,在有许多已沉没项目的大海里漂流,不断抓住最新的时尚,就像是遇到海难的人紧紧抓住漂来的木头一样.每当有新的木头漂过时,他们都会费力地游过去,希望这一块会更好.但到最后,不管漂浮物有多好,这些开发者仍然漫无目的地漂流着<h6>第8章 注重实效的项目 Pragmatic Projects</h6><p>一旦参与项目的人员超过一个,你就需要建立一些基本原则,并相应的分派任务<p>作为整体的团队甚至更容易被煮熟.大家认为,另外有人在处理某个问题,或是团队领导一定已经批准了用户要求做出的某项改动|即使是目的最明确的团队对项目中的重大改动可能也会很健忘!<p>对外界而言,看上去沉闷寡言的项目团队是最糟糕的团队|他们举行无章次的会议,在会上没有人想说话,他们的文档混乱:没有两份文档有相同的外观,每一份都使用不同的术语<p>杰出的项目团队有着截然不同的个性,"人们希望与他们一同开会,因为他们知道自己将看到准备良好|会让每个人都感到愉悦的演出.他们制作的文档新鲜|准确|一致,团队用一个声音说话.他们甚至还可能有幽默感<p>认为项目的各种活动--分析|设计|编码|测试--会孤立地发生,这是一个错昃,它们不会孤立发生.它们是看待同一问题的不同方式,人为地分隔它们会带来许多麻烦|离代码的用户有两|三层远的程序员不大可能注意到他们的工作的应用语境.他们将无法做出有见识的决策<p>文档和代码是同一底层模型的不同视图,但视图是惟一应该不同的东西.不要让文档变成二等公民,被排除在项目主要工作流之外.对待文档要像对待代码一样用心,用户(还有后来的维护者)会为你唱赞歌的<p>在现实中,项目的成功是由它在多大程度上满足了用户的期望来衡量的.不符合用户预期的项目注定是失败的,不管交付的产品在绝对的意义上有多好.但是,像希望得到廉价洋娃娃的小孩的父母一样,你走得太远也会失败<h5>随想</h5><p>软件开发中遇到的很多情况在书中都有提及,比如需求分析问题,文档问题,团队问题等等.虽然成书已经近20年,但这些程序开发中的事情总是存在,书中的解决办法依然今典有效.感觉能做到一部分就是一个比较有质量的程序员了.<p>工欲善其事必先利其器,软件开发工作更是需要利器.否则效率差距太大了,软件设计前瞻性,解决方案观点,问题解决思路,开发自动化工具,编程经验,沟通策略,等等,这些方面的质量水平就是开发队伍的质量水平.<p>对于一个从蛮荒环境中成长的程序员来讲,一定遇到过书中提到的一些软件开发问题,比如靠运气胡乱试验编程,比如不设计就编码,不写文档,不写注释,随意命名变量,不系统测试等等..阅后也许很惊讶如获至宝,原来解决办法是这样啊.原来资深程序员也遇到过这些开发问题.原来资深程序员的解决办法很高明...那么,自己需要做些什么改变吗?嗯,要做一个"注重实效的程序员".至少,先把文档写规范.</p><br><br><br></div></div><div class=nav-page-inside><h6 class=text-center>本文内容</h6><div class=layout-v id=navOfInPage></div></div></div></div><script src=/asset/js/mainmenu.js></script><script src=/asset/js/navinpage.js></script>