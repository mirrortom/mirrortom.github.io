<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>人月神话 | 弗雷德里克·P·布鲁克斯 | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class=layout-part2><div class=wz-page><p>书名: <strong>人月神话 The Mythical Man-Month</strong> 作者: <strong>弗雷德里克·P·布鲁克斯 FrederickP.Brooks.Jr.</strong><h4>片段记录</h4><h6>第一版序言</h6><p>在很多方面,管理一个大型的计算机编程项目和其它行业的大型工程很相似----比大多数程序员所认为的还要相似;在很多另外的方面,它又有差别----比大多数职业经理所认为的差别还要大<h6>第1章 焦油坑(The Tar Pit)</h6><p>过去几十年的大型系统开发就犹如这样一个焦油坑,很多大型和强壮的动物在其中剧烈地挣扎.他们中大多数开发出了可运行的系统----不过,其中只有非常少数的项目满足了目标|时间进度和预算的要求.各种团队,大型的和小型的,庞杂的和精干的,一个接一个淹没在了焦油坑中<p>首先是一种创建事物的纯粹快乐.如同小孩在玩泥巴时感到愉快一样,成年人喜欢创建事物,特别是自己进行设计<p>对于系统编程人员而言,对其他人的依赖是一件非常痛苦的事情.他依靠其他人的程序,而往往这些程序设计得并不合理,实现拙劣,发布不完整(没有源代码或测试用例),或者文档记录得很糟.所以,系统编程人员不得不花费时间去研究和修改,而它们在理想情况下本应该是可靠完整的<p>另外,人们发现调试和查错往往是线性收敛的,或者更糟糕的是,具有二次方的复杂度.结果,测试一拖再拖,寻找最后一个错误比第一个错误将花费更多的时间<p>诚然,产品开发所基于的技术在不断地进步.一旦设计被冻结,在概念上就已经开始陈旧了.不过,实际产品需要一步一步按阶段实现.实现落后与否的判断应根据其它已有的系统,而不是未实现的概念.因此,我们所面临的挑战和任务是在现有的时间和有效的资源范围内,寻找解决实际问题的切实可行方案<h6>第2章 人月神话(The Mythical Man-Month)</h6><p>第二,我们采用的估算技术隐含地假设人和月可以互换,错误地将进度与工作量相互混淆<p>对于创造者,只有在实现的过程中,才能发现我们构思的不完整性和不一致性.因此,对于理论家而言,书写|试验以及"工作实现"是非常基本和必要的<p>第二个谬误的思考方式是在估计和进度安排中使用的工作量单位:人月.成本的确随开发产品的人数和时间的不同,有着很大的变化,进度却不是如此.因此我认为用人月作为衡量一项工作的规模是一个危险和带有欺骗性的神话.它暗示着人员数量和时间是可以相互替换的<p>当任务由于次序上的限制不能分解时,人手的添加对进度没有帮助<p>特别需要指出的是,不为系统测试安排足够的时间简直就是一场灾难.因为延迟发生在项目快完成的时候.直到项目的发布日期,才有人发现进度上的问题.因此,坏消息没有任何预兆,很晚才出现在客户和项目经理面前<p>向进度落后的项目中增加人手,只会使进度更加落后<p>项目的时间依赖于顺序上的限制,人员的数量依赖于单个子任务的数量.从这两个数值可以推算出进度时间表,该表安排的人员较少,花费的时间较长(唯一的风险是产品可能会过时)<h6>第3章 外科手术队伍(The Surgical Team)</h6><p>在该小组中,最好的和最差的表现在生产率上平均为10:1;在运行速度和空间上具有 5:1 的惊人差异!简言之,$20,000/年的程序员的生产率可能是$10,000/年程序员的 10 倍.数据显示经验和实际的表现没有相互联系(我怀疑这种现象是否普遍成立.)<p>我常常重复这样的一个观点,需要协作沟通的人员的数量影响着开发成本,因为成本的主要组成部分是相互的沟通和交流,以及更正沟通不当所引起的不良结果(系统调试).这一点,也暗示系统应该由尽可能少的人员来开发.实际上,绝大多数大型编程系统的经验显示出,一拥而上的开发方法是高成本的|速度缓慢的|不充分的,开发出的是无法在概念上进行集成的产品<p>Mills 建议大型项目的每一个部分由一个团队解决,但是该队伍以类似外科手术的方式组建,而并非一拥而上也就是说,同每个成员截取问题某个部分的做法相反,由一个人来进行问题的分解,其他人给予他所需要的支持,以提高效率和生产力<dl><dt><b>外科手术队伍</b><dd>外科医生<dd>副手<dd>管理员<dd>编辑<dd>两个秘书<dd>程序职员<dd>工具维护人员<dd>测试人员<dd>语言专家</dl><p>文中定义的开发团队在很多方面满足了迫切性的需要.十个人,其中七个专业人士在解决问题,而系统是一个人或者最多两个人思考的产物,因此客观上达到了概念的一致性<p>在这里,可以认为整个系统必须具备概念上的完整性,要有一个系统结构师从上至下地进行所有的设计.要使工作易于管理,必须清晰地划分体系结构设计和实现之间的界线,系统结构师必须一丝不苟地专注于体系结构.总的说来,上述的角色分工和技术是可行的,在实际工作中,具有非常高的效率<h6>第4章 贵族专制|民主政治和系统设计(Aristocracy,Democracy, and System Design)</h6><p>我主张在系统设计中,概念完整性应该是最重要的考虑因素.也就是说为了反映一系列连贯的设计思路,宁可省略一些不规则的特性和改进,也不提倡独立和无法整合的系统,哪怕它们其实包含着许多很好的设计<p>编程系统(软件)的目的是使计算机更加容易使用.为了做到这一点,计算机装备了语言和各种工具,这些工具实际上也是被调用的程序,受到编程语言的控制.使用这些工具是有代价的:软件外部描述的规模大小是计算机系统本身说明的十倍<p>概念的完整性要求设计必须由一个人,或者非常少数互有默契的人员来实现<p>系统的体系结构(architecture)指的是完整和详细的用户接口说明.对于计算机,它是编程手册;对于编译器,它是语言手册;对于控制程序,它是语言和函数调用手册;对于整个系统,它是用户要完成自己全部工作所需参考的手册的集合<p>最后一个问题是最简单的.我当然不认为只有结构师才有好的创意.新的概念经常来自实现者或者用户.然而,我一直试图表达,并且我所有的经验使我确信,系统的概念完整性决定了使用的容易程度.不能与系统基本概念进行整合的良好想法和特色,最好放到一边,不予考虑.如果出现了很多非常重要但不兼容的构想,就应该抛弃原来的设计,对不同基本概念进行合并,在合并后的系统上重新开始<p>正如我们前面所看到的,实现同样是一项高级别的创造性活动.具体实现中创造和发明的机会,并不会因为指定了外部技术说明而大为减少,相反创造性活动会因为规范化而得到增强<p>如同Blaauw所指出的,整个创造性活动包括了三个独立的阶段:体系结构(architecture)|设计实现(implementation)|物理实现(realization).在实际情况中,它们往往可以同时开始和并发地进行<h6>第5章 画蛇添足(TheSecond-SystemEffect)</h6><p>项目经理如何避免画蛇添足(second-system effect)?他必须坚持至少拥有两个系统以上开发经验结构师的决定.同时,保持对特殊诱惑的警觉,他可以不断提出正确的问题,确保原则上的概念和目标在详细设计中得到完整的体现<h6>第6章 贯彻执行（Passing the Word）</h6><p>手册不但要描述包括所有界面在内的用户可见的一切,它同时还要避免描述用户看不见的事物.后者是编程实现人员的工作范畴,而实现人员的设计和创造是不应该被限制的.体系结构设计人员必须为自己描述的任何特性准备一种实现方法,但是他不应该试图支配具体的实现过程<h6>第7章 为什么巴比伦塔会失败?(Why Did theTower of Babel Fail?)</h6><p>那么,既然他们具备了所有的这些条件,为什么项目还会失败呢?他们还缺乏些什么?两个方面----交流,以及交流的结果----组织.他们无法相互交谈,从而无法合作.当合作无法进行时,工作陷入了停顿.通过史书的字里行间,我们推测交流的缺乏导致了争辩|沮丧和群体猜忌.很快,部落开始分裂----大家选择了孤立,而不是互相争吵<p>使用项目手册的第二个原因是控制信息发布.控制信息发布并不是为了限制信息,而是确保信息能到达所有需要它的人的手中<p>卡内基－梅隆大学的 D.L.Parnas 提出了更彻底的解决方法1.他认为,编程人员仅了解自己负责的部分,而不是整个系统的开发细节时,工作效率最高.这种方法的先决条件是精确和完整地定义所有接口.这的确是一个彻底的解决方法.如果能处理得好,的确是能解决很多"灾难".一个好的信息系统不但能暴露接口错误,还能有助于改正错误<p>事实上,树状组织架构是作为权力和责任的结构出现.其基本原理----管理角色的非重复性----导致了管理结构是树状的.但是交流的结构并未限制得如此严格,树状结构几乎不能用来描述交流沟通,因为交流是通过网状结构进行的.在很多工程活动领域,树状模拟结构不能很精确地用于描述一般团队|特别工作组|委员会,甚至是矩阵结构组织<p>1. 任务(a mission)2. 产品负责人(a producer)3. 技术主管和结构师(a technical director or architect)4. 进度(a schedule)5. 人力的划分(a division of labor)6. 各部分之间的接口定义(interface definitions among the parts)<p>这种组合可以使工作很有效.不幸的是它很少被应用.不过,它至少有一个好处,即项目经理可以使用并不很擅长管理的技术天才来完成工作<p>巴比伦塔可能是第一个工程上的彻底失败,但它不是最后一个.交流和交流的结果----组织,是成功的关键.交流和组织的技能需要管理者仔细考虑,相关经验的积累和能力的提高同软件技术本身一样重要<h6>第8章 胸有成竹(Calling the Shot)</h6><p>实践是最好的老师,但是,如果不能从中学习,再多的实践也没有用<p>使用适当的高级语言,编程的生产率可以提高 5 倍<h6>第9章 削足适履(Ten Pounds in a Five-PoundSack)</h6><p>由于规模是软件系统产品用户成本中如此大的一个组成部分,开发人员必须设置规模的目标,控制规模,考虑减小规模的方法,就像硬件开发人员会设立元器件数量目标,控制元器件的数量,想出一些减少零件的方法.同任何开销一样,规模本身不是坏事,但不必要的规模是不可取的<p>另外一种方法是认识到编程需要技术积累,需要开发很多公共单元构件.每个项目要有能用于队列|搜索和排序的例程或者宏库.对于每项功能,库至少应该有两个程序实现:运行速度较快和短小精炼的.上述的公共库开发是一件重要的实现工作,它可以与系统设计工作并行进行<h6>第10章 提纲挈领(The Documentary Hypothesis)</h6><p>任何管理任务的关注焦点都是时间|地点|人物|做什么|资金<p>我并不是很同意销售人员所吹捧的"完备信息管理系统"----管理人员只需在计算机上输入查询,显示屏上就会显示出结果.有许多基本原因决定了上述系统是行不通的.一个原因是只有一小部分管理人员的时间----可能只有 20%----用来从自己头脑外部获取信息<h6>第11章 未雨绸缪(Plan to Throw One Away)</h6><p>对于大多数项目,第一个开发的系统并不合用.它可能太慢|太大,而且难以使用,或者三者兼而有之.要解决所有的问题,除了重新开始以外,没有其他的办法----即开发一个更灵巧或者更好的系统.系统的丢弃和重新设计可以一步完成,也可以一块块地实现.所有大型系统的经验都显示,这是必须完成的步骤2.而且,新的系统概念或新技术会不断出现,所以开发的系统必须被抛弃,但即使是最优秀的项目经理,也不能无所不知地在最开始解决这些问题<p>因此,管理上的问题不再是"是否构建一个试验性的系统,然后抛弃它?"你必须这样做<p>当系统发生变化时,管理结构也需要进行调整.这意味着,只要管理人员和技术人才的天赋允许,老板必须对他们的能力培养给予极大的关注,使管理人员和技术人才具有互换性<p>组建外科手术队伍式的软件开发团队,这整个观念是对上述问题的彻底冲击.其结果是当高级人才编程和开发时,不会感到自降身份.这种方法试图清除那些会剥夺创造性乐趣的社会障碍<p>软件维护不包括清洁|润滑和对损坏器件的修复.它主要包含对设计缺陷的修复.和硬件维护相比,这些软件变更包含了更多的新增功能,它通常是用户能察觉的<p>对于一个广泛使用的程序,其维护总成本通常是开发成本的 40％或更多.令人吃惊的是,该成本受用户数目的严重影响.用户越多,所发现的错误也越多<p>程序维护中的一个基本问题是----缺陷修复总会以(20－50)%的机率引入新的 bug.所以整个过程是前进两步,后退一步<p>系统软件开发是减少混乱度(减少熵)的过程,所以它本身是处于亚稳态的.软件维护是提高混乱度(增加熵)的过程,即使是最熟练的软件维护工作,也只是放缓了系统退化到非稳态的进程<h6>第12章 干将莫邪(Sharp Tools)</h6><p>这种方法对软件项目来说是愚蠢的.首先,项目的关键问题是沟通,个性化的工具妨碍----而不是促进沟通.其次,当机器和语言发生变化时,技术也会随之变化,所有工具的生命周期是很短的.毫无疑问,开发和维护公共的通用编程工具的效率更高<h6>第13章 整体部分(The Whole and the Parts)</h6><p>Bell 实验室安全监控系统项目的 V.A.Vyssotsky 提出,"关键的工作是产品定义.许许多多的失败完全源于那些产品未精确定义的地方.1"细致的功能定义|详细的规格说明|规范化的功能描述说明以及这些方法的实施,大大减少了系统中必须查找的 bug 数量<p>当遇到一些意想不到的问题时,按部就班的流程并不意味着步骤不能反过来,直到推翻顶层设计,重新开始整个过程.实际上,这种情况经常发生.至少,它让我们更加清楚在什么时候和为什么抛弃了某个臃肿的设计,并重新开始.一些糟糕的系统往往就是试图挽救一个基础很差的设计,而对它添加了很多表面装饰般的补丁.自顶向下的方法减少了这样的企图<h6>第14章 祸起萧墙(Hatching a Catastrophe)</h6><p>但是一天一天的进度落后是难以识别|不容易防范和难以弥补的.昨天,某个关键人员生病了,无法召开某个会议.今天,由于雷击打坏了公司的供电变压器,所有机器无法启动.明天,因为工厂磁盘供货延迟了一周,磁盘例程的测试无法进行.下雪|应急任务|私人问题|同顾客的紧急会议|管理人员检查----这个列表可以不断地延长.每件事都只会将某项活动延迟半天或者一天,但是整个进度开始落后了,尽管每次只有一点点<p>里程碑的选择只有一个原则,那就是,里程碑必须是具体的|特定的|可度量的事件,能够进行清晰定义.以下是一些反面的例子,例如编码,在代码编写时间达到一半的时候就已经"90％完成"了;调试在大多时候都是"99％完成"的;"计划完毕"是任何人只要愿意,就可以声明的事件<p>里程碑有明显边界和没有歧义,比它容易被老板核实更为重要.如果里程碑定义得非常明确,以致于无法自欺欺人时,很少有人会就里程碑的进展弄虚作假.但是如果里程碑很模糊,老板就常常会得到一份与实际情况不符的报告.毕竟,没有人愿意承受坏消息.这种做法只是为了起到缓和的作用,并没有任何蓄意的欺骗<p>对计划和控制职能进行适度的技术人力投资是非常值得赞赏的.它对项目的贡献方式和直接开发软件产品有很大的不同.计划和控制小组作为监督人员,明白地指出了不易察觉的延迟,并强调关键的因素.他们是早期预警系统,防止项目以一次一天的方式落后一年<h6>第15章 另外一面(The other face)</h6><p>不了解,就无法真正拥有<p>计算机程序是从人传递到机器的一些信息.为了将人的意图清晰地传达给不会说话的机器,程序采用了严格的语法和严谨的定义<p>即使是完全开发给自己使用的程序,这种沟通仍然是必要的.因为记忆衰退的规律会使用户－作者失去对程序的了解,于是他不得不重拾自己劳动的各个细节<p>数据处理的基本原理告诉我们,试图把信息放在不同的文件中,并努力维持它们之间的同步,是一种非常费力不讨好的事情.更合理的方法是:每个数据项包含两个文件都需要的所有信息,采用指定的键值来区别,并把它们组合到一个文件中<p>我认为相应的解决方案是"合并文件",即把文档整合到源代码.这对正确维护是直接有力的推动,保证编程用户能方便|即时地得到文档资料.这种程序被称为自文档化(self-documenting)<h6>第16章 没有银弹－软件工程中的根本和次要问题(No Silver Bullet – Essence and Accident in Software Engineering)</h6><p>解决管理灾难的第一步是将大块的"巨无霸理论"替换成"微生物理论",它的每一步----希望的诞生,本身就是对一蹴而就型解决方案的冲击.它告诉工作者进步是逐步取得的,伴随着辛勤的劳动,对规范化过程应进行持续不懈的努力.由此,诞生了现在的软件工程<p>不仅仅是在目力所及的范围内,没有发现银弹,而且软件的特性本身也导致了不大可能有任何的发明创新----能够像计算机硬件工业中的微电子器件|晶体管|大规模集成一样----提高软件的生产率|可靠性和简洁程度.我们甚至不能期望每两年有一倍的增长<p>软件的复杂度是必要属性,不是次要因素.因此,抽掉复杂度的软件实体描述常常也去掉了一些本质属性.数学和物理学在过去三个世纪取得了巨大的进步,数学家和物理学家们建立模型以简化复杂的现象,从模型中抽取出各种特性,并通过试验来验证这些特性.这些方法之所以可行----是因为模型中忽略的复杂度不是被研究现象的必要属性.当复杂度是本质特性时,这些方法就行不通了<p>除去软件结构上的限制和简化方面的进展,软件仍然保持着无法可视化的固有特性,从而剥夺了一些具有强大功能的概念工具的构造思路.这种缺憾不仅限制了个人的设计过程,也严重地阻碍了相互之间的交流<p>分时所起作用也非常有限.主要效果是缩短了系统的响应时间.随着它接近于零,到达人类可以辨识的基本能力----大概 100 毫秒时,所获得的好处就接近于无了<p>专家系统是包含归纳推论引擎和规则基础的程序,它接收输入数据和假设条件,通过从基础规则推导逻辑结果,提出结论和建议,向用户展示前因后果,并解释最终的结果.推论引擎除了处理推理逻辑以外,通常还包括复杂逻辑或者概率数据和规则<p>因此,现在的技术中最有希望的,并且解决了软件的根本而非次要问题的技术,是开发作为迭代需求过程的一部分----快速原型化系统的方法和工具<p>让我们转向自然界,研究一下生物的复杂性,而不是人们的僵硬工作.我们会发现它们的复杂程度令我们敬畏.光是大脑本身,就比任何对它的描述都要复杂,比任何的模拟仿真都要强大,它的多样性|自我保护和自我更新能力异常丰富和有力.其中的秘密就是逐步发育成长,而不是一次性搭建<h6>第17章 再论没有银弹("No Silver Bullet"Refired)</h6><p>作为本质上的困难,构思软件概念性的结构本身就有复杂性|一致性|可变性及不可见性的特点.不过实际上,每一种困难产生的麻烦都是可以改善的<p>使用更大的零件来构建.面向对象编程的第一个特征是,它强制的模块化和清晰的接口.其次,它强调了封装,即外界无法看到组件的内部结构;它还强调了继承和层次化类结构以及虚函数.面向对象还强调了强抽象数据类型化,它确保某种特定的数据类型只能由它自身的相应函数来操作<p>思索的层次越高,所需要处理的基本思考要素也就越多.因此,编程语言比机器语言更加复杂,而自然语言的复杂程度更高.高级语言有更广泛的词汇量|更复杂的语法以及更加丰富的语义<h6>第18章 人月神话的观点:是或非?(Propositionsof the Mythical Man-Month: True orFalse?)</h6><p>8.6 IBM 的 Aron 数据显示,生产率是系统各个部分交互的函数,在 1.5K 千代码行/人年至 10K 千代码行/人年的范围内变化<h6>第19章 20 年后的人月神话(The MythicalMan-Month after 20 Years)</h6><p>因此,某种程度上,人月神话 是关于人与团队的书,所以它的淘汰过程会是缓慢的<p>在过去 20 年内,软件开发领域中,令人印象最深刻的进步是窗口(Windows)|图标(Icons)|菜单(Menus)|指针选取(Pointing)界面的成功----或者简称为 WIMP.这些在今天是如此的熟悉,以致于不需要任何解释.这个概念首先在 1968 年西部联合计算机大会(Western Joint Computer Converence)上,由斯坦福研究机构(Stanford Research Institute)的 Doug Englebart 公开提出<p>强制体系结构的实施,作为设备的直接整合.Mac 界面在另一个方面很值得注意.没有任何强迫,它的设计人员在所有的应用程序中使用标准界面,包括了大量的第三方程序.从而,用户在界面上获得的概念一致性不仅仅局限在机器所配备的软件,而且遍及所有的应用程序<p>David Parnas 认为代码模块应该采用定义良好的接口来封装,这些模块的内部结构应该是程序员的私有财产,外部是不可见的.编程人员被屏蔽而不是暴露在他人模块内部结构面前.这种情况下,工作效率最高<p>如同 Ferrell 故事所展现的,在几乎 50 年后,我仍被化学工程和软件工程之间的很多相似之处所震动.Parans 对我写的关于软件工程(software engineering)的文章提出了批评.他对比了电气工程和软件领域,觉得把我们所做的称为"工程"十分冒昧.他可能是正确的,这个领域可能永远不会发展成像电气工程那样的工程化领域,拥有精确的数学基础.毕竟,软件工程就像化学工程一样,与如何扩展到工业级别处理过程的非线性问题有关.而且,和工业工程类似,它总是被人类行为的复杂性所困扰<h5>随想</h5><p>从计算机发明以来,硬件一直是在稳步发展的道路上.而软件的发展却迟迟不得要领,好像一个在蛮荒地中寻找道路的人,不停的曲折绕圈,然而却找不到正路.没有银弹似乎是一个悲哀的结论,但即使是这个结论,也是在无尽的探索中艰难的得到的.在没有高级语言的早期,用汇编语言,内存使用要精打细算的时代,开发出大型软件,真的是一件非常了不起的事.现在丰富的软硬件资源,可以让一个人很快的编出hello world,但是要成为一个入门的软件工程师,却依然不是一件容易的事.了解计算机软件工业早期开荒的历史是必要的,软件开发管理,如"外科手术团队",软件开发技术,如"面向对象".先贤的探索成果是巨大的,外科手术团队在今天也绝不过时,技术也不会,技术一直在发展啊.</p><br><br><br></div></div></div><script src=/asset/js/mainmenu.js></script>