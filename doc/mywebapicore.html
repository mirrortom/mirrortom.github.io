<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content=#da532c><meta name=theme-color content=#ffffff><title>webapi core | Mirror Space</title><link href=/mirrorui/mirrorui.css rel=stylesheet><link href=/mirroricon/mirroricon.css rel=stylesheet><link href=/asset/css/blog.css rel=stylesheet><div class=layout><div class=layout-part1></div><div class="layout-part2 layout-doc"><div id=page_content><h1>Asp.Net Core自定义webapi框架</h1><p><small>最后更新: 2024/10/07</small> <small>建立: 2019/5/10</small><p>(github)<a href=https://github.com/mirrortom/MyWebApiCore target=_blank>https://github.com/mirrortom/MyWebApiCore</a><h2>简介</h2><p>项目基于NET8.0的ASP.NET CORE空项目模板.主要功能是将url解析到类的方法上.是一个简单的webapi功能框架.<h4>1. 主要文件</h4><ul class="list num"><li>ApiHandler.cs: 自定义的"中间件"类.含有url解析中间件和异常处理中间件.<li>ApiBase.cs: 提供一些便利方法.如取参数,返回结果等,所有webapi类要继承此类.<li>ApiAttr.cs: 用于webapi类或者方法的特性.比如[HTTPGET][HTTPPOST][AUTHBase]<li>Config.cs: 读取settings.json文件,生成配置项,供程序所需设置.<li>settings.json: 自定义的配置文件,配置监听端口和其它选项.json格式,也可以加入其它配置项.</ul><h4>2. webapi类约定</h4><ul class="list num"><li>类名以Api结尾<li>类要继承ApiBase<li>类的方法上要贴上特性[HTTPGET][HTTPPOST]之1或者2者</ul><h2>建立测试项目</h2><ul class="list num"><li>用VS2022建一个asp.net core的空项目.选.NET 8.0<li>复制文件夹core里的文件,还有settings.json,以及Program.cs<li>加入引用Newtonsoft.Json这些用到的工具库<li>F5运行项目,打开浏览器测试.测试页面地址在控制台窗口查找.</ul><p>一般情况下,web项目主要是接受请求,管理html页面,属于UI端,程序集目录简单,可能会有一个wwwroot静态文件目录,其它内容会另外建立程序集.<h2>部署</h2><ul class="list num"><li>直接部署,kestrel是可以用于边缘的web服务器.不用部署到其它web服务器环境内.但官方文档不推荐.<li>部署到IIS,Apache,nginx这些服务后面.托管asp.net core应用,也就是放在代理服务器后面.<li>在windows平台,可以托管在windows服务下,asp.net core程序支持以windows服务方式托管运行.只需要做很少的修改,这是种成本较低的部署方式.</ul><h4>1. IIS托管代理</h4><p>由IIS做监听,请求转发到kestrel. <a href="https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/out-of-process-hosting?view=aspnetcore-8.0">(文档)https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/out-of-process-hosting?view=aspnetcore-8.0</a><ul class="list num"><li>IIS需要安装".NET Core 托管捆绑包".安装后IIS的模块里会多出两个模块: AspNetCoreModule 和 AspNetCoreModuleV2 <a href="https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/hosting-bundle?view=aspnetcore-8.0">(地址:)https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/hosting-bundle?view=aspnetcore-8.0</a><li>发布程序,选择发布到文件,选择 "独立" 部署模式,运行时选择 "WIN-64"<li>在IIS里新建立网站,程序池选择"无托管".物理目录里放入发布的项目.<li>web.config文件,发布项目时(win平台)会生成这个文件.把它复制到网站下.配置如下: <a href="https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-8.0">(web.config文档) https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/iis/web-config?view=aspnetcore-8.0</a></ul><pre>
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;configuration>
&lt;location path="." inheritInChildApplications="false">
&lt;system.webServer>
  &lt;handlers>
    &lt;add name="aspNetCore" path="*" verb="*" modules="AspNetCoreModuleV2" resourceType="Unspecified" />
  &lt;/handlers>

  // 进程名字是自己项目的
  &lt;aspNetCore processPath="<strong>.\项目名字.exe</strong>"
              stdoutLogEnabled="false"
              stdoutLogFile=".\logs\stdout"

              // 要使用进程外托管.
              hostingModel=<strong>"outofprocess"</strong>/>
&lt;/system.webServer>
&lt;/location>
&lt;/configuration>
</pre><p>托管方式也可以在项目的.csproj里添加 &lt;AspNetCoreHostingModel>OutOfProcess[InProcess]&lt;/AspNetCoreHostingModel> 来说明进程外(内)托管.这样项目发布后,web.config文件中的托管方式值会以设定的值生成.<h4>2. 以windows服务方式托管运行</h4><p>部署成服务时,可以当成一个本地程序,就像控制台程序但没有黑窗口.可用本机网页做交互UI.文档:<a href="https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/windows-service?view=aspnetcore-8.0&tabs=visual-studio">https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/windows-service?view=aspnetcore-8.0&tabs=visual-studio</a><ul class="list num"><li>添加包引用 <a href=https://www.nuget.org/packages/Microsoft.Extensions.Hosting.WindowsServices>Microsoft.AspNetCore.Hosting.WindowsServices</a><li>打开PowerShell管理员,使用sc命令建立一个windows服务:(下面MyWebApiServer是服务名字,binPath是exe程序路径.DisplayName是服务显示名字)<li>sc.exe create MyWebApiServer binPath="D:/MyWebApiPublisher/MyWebApi.exe" DisplayName=MyWebApiOnWinServer<li>如果建立成功了,那么打开services.msc 就能找到这个服务,然后点击启动服务.成功后可打开浏览器试调API</ul><p>可以用sc命令启动/停止服务: sc start/stop [SrvName]<h4>3. 部署到linux</h4><p>发布文件,选择 "独立" 部署模式,运行时选择 "linux-64"<p>文件复制到linux下,运行 MyWebApi.exe文件启动项目.<p>在linux下,一般需要做nginx托管代理<a href="https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-9.0">(文档:)https://learn.microsoft.com/zh-cn/aspnet/core/host-and-deploy/linux-nginx?view=aspnetcore-8.0</a><p>还要以系统服务进程开启项目.这个用systemctl这个工具.<h2>静态文件</h2><p>静态文件参考文档: <a href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-8.0">https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-8.0</a><p>静态文件的默认目录是 wwwroot ,位于目录 {content root}/wwwroot<p>调用无参数系统中间件 UseStaticFiles() 方法重载将启用静态文件功能, 提供wwwroot目录中的文件.<h4>1. 自定义其它静态文件目录</h4><p>调用有参数的 UseStaticFiles(StaticFileOptions[]).参数里指定了一个物理目录和对应的虚拟目录.<p>这个功能可以在kestrel服务器建立虚拟目录.例如内容根下的一个目录 "/contentRoot/img" 虚拟目录 "/cdn/img"<h4>2. 默认文档</h4><p>指定一个文件在网址打开时不带url时显示.例如 index.html<p>调用系统中间件 UseDefaultFiles(DefaultDocOptions) 参数方法可以添加多个默认文档.<h2>必要概念</h2><div class=layout-h><div><canvas id=canv1></canvas></div><div><p>asp.net core基础概念文档:<a href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/?view=aspnetcore-7.0&tabs=windows">https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/?view=aspnetcore-7.0&tabs=windows</a><h4>1. 容器层次</h4><p>从core2.1到.net 8,水平差依然是觉得复杂看不明白.现在8.0文档比较丰富,感觉有点思路了.开始有一个主机,这是所有东西的容器(Host类),是封装应用资源的对象.比如主机管理配置信息/环境变量/日志,可以添加服务(IServiceCollection)/web主机(IWebHostBuilder)等.web主机也是容器,是提供web服务的,可以选择一种监听服务器,比如Kestrel(默认)或者IIS,也可以自定义服务器.web服务器可以承载应用程序IApplicationBuilder,应用程序里面就是功能模块MiddleWare.</div></div><h4>2. 配置</h4><p><a href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-7.0">(Asp.Net)https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/configuration/?view=aspnetcore-7.0</a><p><a href=https://learn.microsoft.com/zh-cn/dotnet/core/extensions/configuration>(.NET)https://learn.microsoft.com/zh-cn/dotnet/core/extensions/configuration</a><p>配置途径真是五花八门.最后使用json文件方式<pre>
// 系统自带的解析配置类
IConfiguration config = new ConfigurationBuilder()
            .AddJsonFile("settings.json")
            .Build();

// 支持索引器取json里的值还算比较方便 支持数组和KV

// {key:"val1",key2:{key21:21}}
config.GetValue&lt;string>("key") 或 config["key"]
config.GetValue&lt;int>("key2:key21") // 21

// {vers:[1,2,3,4,5]}
config.GetValue&lt;int>("vers:0") // 1

// {psnode:[{k:1,v:1},{k:2,v:2},...]} 取一个数组转化成字典数组
config.GetSection("psnode").Get&lt;Dictionary&lt;string, string>[]>();
</pre><h4>3. 中间件</h4><p><a href="https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0">(文档)https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0</a><p>实现功能的程序,比如解析URL,处理异常,跨域等,都是通过加载中间件实现.系统已经内置了很多中间件,直接选用就行.需要实现特定功能就做一个中间件.<p>若干中间件组成管道处理链条,顺序很重要.比如异常中间件需要在其它中间件之前加载,否则异常出现了,异常处理中间件还没加载.静态文件中间件要在动态处理中间件之前加载.<p>中间件执行完会执行下一个,传递HttpContext对象.有些不会传递,比如静态文件中间件,请求到静态文件中间件后,如果找到了页面,就会返回页面,中止请求,这个是中间件短路.加载自定义中间件的方法是Use(),如果要加载一个短路中间件,可以使用Run(),一般最后一个中间件可以用Run()加载.<h4>4. C#</h4><p>需要了解的C#相关知识. Delegate 泛型 async异步方法 依赖注入DI Task 异常处理 反射 序列化<h2>差别</h2><p>Asp.Net Core与经典的asp.net的差别比较大了,功能上感觉更先进,也更复杂.Asp.Net Core是一个可以承载多种功能的容器平台了,不再仅仅是web服务.<ul class="list num"><li>自带服务器kestrel,可以独立部署.除了windows,可部署Linux,真正跨平台.<li>中间件方式实现功能模块,可以按需加载,而不用限制在asp.net的十几个事件点上.<li>系统自带了丰富的中间件,像跨域之类的.只需要配置一下跨域规则.Asp.Net Core上的mvc webapi框架也都有,使用习惯比经典版本类似.不过前后端分离的话,这些框架基本没用了.</ul><hr class=line><script src=/mirrorui/mirrorui.js></script><script src=/cavlib/cavlib.js></script><script>(()=>{function n(){let t=cavlib("canv1").style(),o=t.ctx;t.width=160;t.height=300;o.font="14px serial";let s={x:20,y:20};o.translate(s.x,s.y);let e={w:120,h:260,color:"blue"};t.p2Rect(0,0,e.w,e.h,0,e.color);t.pointChar(0,0,"Host",30,e.color);let n={x:10,y:20,w:80,h:16,color:"green"};t.p2Rect(n.x,n.y,n.x+n.w,n.y+n.h,1,n.color);t.p2Rect(n.x,2*n.y,n.x+n.w,2*n.y+n.h,1,n.color);t.pointChar(n.x,n.y*1.5,"Srv1",0,n.color);t.pointChar(n.x,n.y*2.5,"Srv2",0,n.color);let r={x:10,y:80,w:100,h:160,color:"orange"};t.p2Rect(r.x,r.y,r.x+r.w,r.y+r.h,1,r.color);t.pointChar(r.x,r.y,"WebHost",20,r.color,35);let u={x:20,y:110,w:80,h:120,color:"red"};t.p2Rect(u.x,u.y,u.x+u.w,u.y+u.h,1,u.color);t.pointChar(u.x,u.y,"Kestrel/IIS",20,u.color,40);let f={x:30,y:140,w:60,h:80,color:"darkblue"};t.p2Rect(f.x,f.y,f.x+f.w,f.y+f.h,1,f.color);t.pointChar(f.x,f.y+20,"WebApp",0,f.color,30);let i={x:40,y:180,w:40,h:10,color:"brown"};t.p2Rect(i.x,i.y,i.x+i.w,i.y+i.h,1,i.color);t.p2Rect(i.x,i.y+20,i.x+i.w,i.y+20+i.h,1,i.color)}n()})(window)</script></div><div class=nav-page-inside><h6 class=text-center>本文内容</h6><div class=layout-v id=navOfInPage></div></div></div></div><script src=/asset/js/mainmenu.js></script><script src=/asset/js/navinpage.js></script>