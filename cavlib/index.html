<!DOCTYPE html><html lang=en><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1.0,user-scalable=no"><link href=/mirrorui/mirrorui.css rel=stylesheet><title>cavlib-doc | Mirror Space</title><style>.page{display:grid;grid-template-columns:210px auto}.menu-box{position:sticky;top:0;width:94%;max-height:100vh;overflow-x:hidden;overflow-y:auto}.doc-part-box{margin:50px auto}</style><body><script src=cavlib.js></script><div class=page><div class="menu-box pd-l-10 pd-b-30"><m-docmenu id=main_menubox><ul class=docmenu-group><li><span class=docmenu-title><i class=docmenu-open></i>About</span><li><a class=docmenu-item href=#about>关于</a><li><a class=docmenu-item href=#cavlib>cavlib</a></ul><ul class=docmenu-group><li><span class=docmenu-title><i class=docmenu-open></i>坐标系</span><li><a class=docmenu-item href=#xyAxis>xyAxis</a><li><a class=docmenu-item href=#lineArrow>lineArrow</a><li><a class=docmenu-item href=#p2Rect>p2Rect</a><li><a class=docmenu-item href=#pointVH>pointVH</a><li><a class=docmenu-item href=#pointTag>pointTag</a><li><a class=docmenu-item href=#pointChar>pointChar</a></ul></m-docmenu></div><div class="content pd-15"><div id=about><h2>关于cavlib</h2><p>canvas绘画的库,模仿jQuery语法风格.</div><div class=doc-part-box id=cavlib><h2>全局对象</h2><p>内部对象canvalib,是一个类数组对象.也是模仿jQuery的,里面包含canvas元素引用和ctx(2D)绘画对象和库提供的工具方法.<pre class=bg-gray-lt>

    // 类数组对象,存放用id选取的canvas元素和2D绘画对象.
    // 返回this,可以链式调用 
    function canvalib(canvasId){
             ...
             return this;
    }

    // 属性
    this.canvas
    this.ctx

    // 工厂函数,实例化这个对象.
    function factory(selector){
        return new canvalib(canvasId);
    }

    // 引用对象 外部调用这个函数使用cavlib对象.
    window.cavlib = factory;
     
</pre><br><p class=article-title>style实例方法<p>调用工厂函数实例化后,可以调用style给画布设置样式风格<pre class=bg-gray-lt>

    // 给canva元素设置style
    // 0:灰色背景,默认值 其它值:未实现
    window.cavlib('canvasDomId').style(num = 0);
 
</pre><br><p class=article-title>扩展cavlib对象实例方法<pre class=bg-gray-lt>

    // 为cavlib对象添加实例方法 prototype上的方法.
    // json 一个方法名和函数值的json对像.方法名要用""号包起来.
    cavlib.extend(json)

</pre><br></div><div class=doc-part-box id=xyAxis><h2>xyAxis</h2><p>在画布上绘制直角坐标系辅助线.省略所有参数时,坐标轴以画布中心为原点,长度为画布长/高<pre class=bg-gray-lt>

    this.xyAxis(style = 0, oX = 0, oY = 0, oXLen = 0, oYLen = 0, oXLen1 = 0, oYLen1 = 0)

</pre><ul class="list square"><li>style : number 风格<ul class="list cir"><li>0 : 原点在中心,轴长等于画布长,虚线<li>1 : 同0,实线<li>2或大于2 : 自定义原点位置和轴长,偶数时虚线,奇数时实线</ul><li>oX : number 原点x坐标<li>oY : number 原点y坐标<li>oXLen : number x正轴长度<li>oYLen : number y正轴长度<li>oXLen1 : number x负轴长度<li>oYLen1 : number y负轴长度</ul><canvas id=canv_xyAxis></canvas></div><div class=doc-part-box id=lineArrow><h2>lineArrow</h2><p>连接2个或者以上的点,结束时画上箭头.箭头底边与线段最后一段垂直<pre class=bg-gray-lt>

    this.lineArrow(points, side = 12, height = 10, fill = true)

</pre><ul class="list square"><li>points : Array(number) 点坐标数组: x1,y1,x2,y2,....<li>side : number 箭头底边长<li>height : number 箭头高<li>fill : boolean true(实心)false(空心)</ul><canvas id=canv_lineArrow></canvas></div><div class=doc-part-box id=p2Rect><h2>p2Rect</h2><p>根据对角线上2点画出矩形<pre class=bg-gray-lt>

    this.p2Rect(x1, y1, x2, y2, style = 0)

</pre><ul class="list square"><li>x1 : number 点x坐标<li>y1 : number 点x坐标<li>x2 : number 对角点x坐标<li>y2 : number 对角点y坐标<li>style : number 风格: 0偶数时虚线,1实线</ul><canvas id=canv_p2Rect></canvas></div><div class=doc-part-box id=pointVH><h2>pointVH</h2><p>画坐标系中的一点到x/y轴的垂直和水平连线<pre class=bg-gray-lt>

    this.p2Rect(x, y, style = 0, oX = 0, oY = 0)

</pre><ul class="list square"><li>x : number 点x坐标<li>y : number 点x坐标<li>style : number 风格: 0(原点在中心,虚线),1(同0,实线) 其它:指定原点,偶数虚线奇数实线<li>oX : number 原点x坐标<li>oY : number 原点y坐标</ul><canvas id=canv_pointVH></canvas></div><div class=doc-part-box id=pointTag><h2>pointTag</h2><p>标记一个点,用于放大显示<pre class=bg-gray-lt>

    this.pointTag(x, y, style = 0, cir = 3, color = 'black')

</pre><ul class="list square"><li>x : number 点x坐标<li>y : number 点x坐标<li>style : number 风格: 0(圆点),1(正方形)<li>cir : number 圆半径/正方形半边长<li>color : string 填充颜色fillStyle</ul><canvas id=canv_pointTag></canvas></div><div class=doc-part-box id=pointChar><h2>pointChar</h2><p>标记一个点,用于放大显示<pre class=bg-gray-lt>

    this.pointChar(x, y, char, deg = 0, cir = 20, color = 'black')

</pre><ul class="list square"><li>x : number 点x坐标<li>y : number 点x坐标<li>char : string 字母<li>deg : number 极角(0~359). 点为圆心,字母标记在圆周的一个点上.X轴正方向为0度,顺时针.<li>cir : number 极径. 字母到点半径.<li>color : string 填充颜色fillStyle</ul><canvas id=canv_pointChar></canvas></div><script>(n=>{let t=n.cavlib("canv_lineArrow").style();t.lineArrow([20,20,200,20]);t.lineArrow([20,40,200,40],12,10,!1);t.lineArrow([50,50,100,100,120,60]);t.lineArrow([10,130,30,130,30,110,50,110]);let i=n.cavlib("canv_xyAxis").style();i.xyAxis();i.xyAxis(3,10,140,50,50,0,0);i.xyAxis(4,220,120,50,30,20,20)})(window);(n=>{let t=n.cavlib("canv_p2Rect").style(),a=t.ctx,u=50,f=40,e=160,o=85,s=20,h=60,c=260,l=135;t.p2Rect(u,f,e,o);t.p2Rect(s,h,c,l,1);let r=[[u,f],[e,o],[s,h],[c,l]];for(var i=0;i<r.length;i++)t.pointTag(r[i][0],r[i][1],0,3,"blue")})(window);(n=>{let t=n.cavlib("canv_pointVH").style(),s=t.ctx,u=20,f=60,e=120,o=-35;t.xyAxis();t.pointVH(u,f);t.pointVH(e,o,1);let r=[[u,f],[e,o]];for(var i=0;i<r.length;i++)t.pointTag(r[i][0]+t.canvas.width/2,r[i][1]+t.canvas.height/2,0,3,"red")})(window);(n=>{let t=n.cavlib("canv_pointTag").style(),e=t.ctx,i=20,r=60,u=120,f=35;t.xyAxis();t.pointTag(i,r);t.pointTag(i+20,r+20,0,4);t.pointTag(u,f,1,2,"red");t.pointTag(u+30,f+20,1,5,"green")})(window);(n=>{let t=n.cavlib("canv_pointChar").style(),e=t.ctx;e.font="18px serial";let i=30,r=60,u=220,f=45;t.xyAxis();t.pointTag(i,r);t.pointChar(i,r,"A");t.pointTag(i+20,r+30);t.pointChar(i+20,r+30,"A1",135,20,"green");t.pointTag(u,f,1,2);t.pointChar(u,f,"B",90,30,"red")})(window)</script></div></div><script src=/jslib/jslib.js></script><script src=/mirrorui/mirrorui.js></script><script>$("#main_menubox")[0].create()</script>